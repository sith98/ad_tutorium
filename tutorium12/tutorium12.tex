\documentclass[11pt,a4paper]{article}

\usepackage{gastex}
\usepackage{etoolbox}
% \newcommand{\showLoesung}{2} %<---als Schalter
% \newcommand{\showInhalt}{1} %<---als Schalter
% \newcommand{\volbert}{3} %<---als Schalter

\input{../skel/uebmacsPNG}

\usepackage{enumitem}
\usepackage{algpseudocode}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{placeins}
\usepackage{multicol}
\usepackage{slashbox}
\usepackage{fancyvrb}
\usepackage{ulem}
\usepackage{amssymb}

\begin{document}
\thispagestyle{empty}
\DeclareRobustCommand{\ttfamily}{\fontencoding{T1}\fontfamily{lmtt}\selectfont}

\newcommand{\quotes}[1]{\glqq{}#1\grqq{}}

\Uebung{12}{13}{Simon Thelen}{20. Januar 2021}  % FIXME: Blattnummer, Datum, Zeit

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\ifcsdef{showLoesung}{
\textbf{Bitte beachten Sie:} Die Lösungen können trotz sorgfältiger Prüfung Fehler enthalten.
Bei Fragen oder Unklarheiten kontaktieren Sie bitte den Tutor oder Dozenten in Tutorien, Übungen oder nach Vorlesungen.
}{}

\begin{aufgabe}{1}{\textnormal{\textsc{APSP}} und \textnormal{\textsc{FasterAPSP}}}
    Gegeben sei der Graph $G_1$:
    \begin{figure}[h!]
        \centering
        \begin{tikzpicture}[scale=0.15]
            \tikzstyle{every node}+=[inner sep=0pt]
            \draw [black] (25.6,-17.5) circle (3);
            \draw (25.6,-17.5) node {$1$};
            \draw [black] (51.7,-17.5) circle (3);
            \draw (51.7,-17.5) node {$2$};
            \draw [black] (25.6,-40.1) circle (3);
            \draw (25.6,-40.1) node {$3$};
            \draw [black] (51.7,-40.1) circle (3);
            \draw (51.7,-40.1) node {$4$};
            \draw [black] (38.8,-28.2) circle (3);
            \draw (38.8,-28.2) node {$5$};
            \draw [black] (28.213,-18.972) arc (58.55225:43.39089:41.986);
            \fill [black] (36.82,-25.95) -- (36.63,-25.02) -- (35.91,-25.71);
            \draw (33.75,-21.68) node [above] {$2$};
            \draw [black] (28.567,-17.055) arc (97.43418:82.56582:77.932);
            \fill [black] (48.73,-17.05) -- (48,-16.46) -- (47.88,-17.45);
            \draw (38.65,-15.9) node [above] {$5$};
            \draw [black] (48.77,-18.144) arc (-79.18957:-100.81043:53.958);
            \fill [black] (28.53,-18.14) -- (29.22,-18.79) -- (29.41,-17.8);
            \draw (38.65,-19.6) node [below] {$-3$};
            \draw [black] (36.872,-30.498) arc (-41.61193:-54.31779:53.459);
            \fill [black] (28.08,-38.42) -- (29.03,-38.36) -- (28.44,-37.55);
            \draw (33.71,-35.19) node [below] {$5$};
            \draw [black] (28.6,-40.1) -- (48.7,-40.1);
            \fill [black] (48.7,-40.1) -- (47.9,-39.6) -- (47.9,-40.6);
            \draw (38.65,-40.6) node [below] {$-1$};
            \draw [black] (49.49,-38.07) -- (41.01,-30.23);
            \fill [black] (41.01,-30.23) -- (41.25,-31.14) -- (41.93,-30.41);
            \draw (46.27,-33.66) node [above] {$2$};
            \draw [black] (51.7,-20.5) -- (51.7,-37.1);
            \fill [black] (51.7,-37.1) -- (52.2,-36.3) -- (51.2,-36.3);
            \draw (51.2,-28.8) node [left] {$4$};
            \draw [black] (27.371,-37.68) arc (141.43987:122.6304:36.412);
            \fill [black] (36.21,-29.71) -- (35.27,-29.72) -- (35.81,-30.56);
            \draw (30.45,-32.84) node [above] {$7$};
            \draw [black] (36.174,-26.752) arc (-121.03069:-137.02618:39.844);
            \fill [black] (27.56,-19.77) -- (27.74,-20.7) -- (28.47,-20.01);
            \draw (30.62,-24.06) node [below] {$2$};
            \draw [black] (25.6,-37.1) -- (25.6,-20.5);
            \fill [black] (25.6,-20.5) -- (25.1,-21.3) -- (26.1,-21.3);
            \draw (26.1,-28.8) node [right] {$4$};
        \end{tikzpicture}
    \end{figure}
    \FloatBarrier
    \begin{enumerate}
        \item Geben Sie die Gewichtsmatrix $W = (w_{ij})$ von $G_1$ an.
        \item Wie muss \textsc{APSP}/\textsc{FasterAPSP} erweitert werden, sodass neben der Distanzmatrix $D$ auch die Vorgängermatrix $\pi$ korrekt bestimmt wird?
        % \item Finden Sie alle kürzesten Wege in $G_1$ mithilfe des Algorithmus \textsc{APSP}.
        % Geben Sie nach jedem Schritt die Matrizen $L$ und $\pi$ an.
        \item Finden Sie alle kürzesten Wege in $G_1$ mithilfe des Algorithmus \textsc{FasterAPSP}.
        Geben Sie nach jedem Schritt die Matrizen $L$ und $\pi$ an.
        \item Ändert sich die ausgegebene Kürzeste-Wege-Matrix $D$ bei \textsc{FasterAPSP}, wenn Sie \textsc{ExtendPaths} eine Iteration häufiger ausführen als vorgesehen?
        Wenn ja, bei welchen Arten von Eingaben?
        % \item Erweitern Sie \textsc{APSP}, sodass der Algorithmus zusätzlich erkennt, ob der Graph negative Zyklen enthält.
        % \begin{description}
        %     \item[Tipp:] Wenn ein Pfad $P$ von $v$ zu $v$ existiert mit $w(P) < 0$, liegt $v$ auf einem negativen Zyklus.
        % \end{description}
    \end{enumerate}
\end{aufgabe}
\begin{loesung}
    \begin{enumerate}
        \item
        \begin{equation*}
            W = \begin{pmatrix}
                0 & 5 & \infty & \infty & 2 \\
                -3 & 0 & \infty & 4 & \infty \\
                4 & \infty & 0 & -1 & 7 \\
                \infty & \infty & \infty & 0 & 2 \\
                2 & \infty & 5 & \infty & 0 
            \end{pmatrix}
        \end{equation*}
        \item
        Zunächst wird $\pi$ am Anfang des Algorithmus, genau wie bei Floyd-Warshall, initialisiert.
        In der Funktion \textsc{ExtendShortestPath} wird neben $L'$ auch $\pi' \gets \pi$ initialisiert.
        Außerdem wird in der innersten \texttt{for}-Schleife die Zeile $l_{ij}' \gets \min(l_{ij}', l_{ik} + w_{kj})$ durch
        \begin{algorithmic}
            \If{$l_{ik} + w_{kj} < l_{ij}'$}
                \State $l_{ij}' \gets l_{ik} + w_{kj}$
                \If{$l_{ij}' < l_{ij}$} \Comment{Echte Verbesserung des kürzesten Weges}
                    \State $\pi_{ij}' \gets \pi_{kj}$ \Comment{Wir gehen jetzt über $k$}
                \EndIf
            \EndIf
        \end{algorithmic}
        ersetzt.
        Am Ende von \textsc{ExtendShortestPath} werden $L'$ und $\pi'$ zurückgegeben und die beiden Matrizen entsprechend aktualisiert.
        % \item
        % \begin{align*}
        %     L^{(1)} &= \begin{pmatrix}
        %         0 & 5 & \infty & \infty & 2 \\
        %         -3 & 0 & \infty & 4 & \infty \\
        %         4 & \infty & 0 & -1 & 7 \\
        %         \infty & \infty & \infty & 0 & 2 \\
        %         2 & \infty & 5 & \infty & 0
        %     \end{pmatrix} \\
        %     L^{(2)} &= \begin{pmatrix}
        %         0 & 5 & 7 & 9 & 2 \\
        %         -3 & 0 & \infty & 4 & -1 \\
        %         4 & 9 & 0 & -1 & 1 \\
        %         4 & \infty & 7 & 0 & 2 \\
        %         2 & 7 & 5 & 4 & 0
        %     \end{pmatrix} \\
        %     L^{(3)} &= \begin{pmatrix}
        %         0 & 5 & 7 & 6 & 2 \\
        %         -3 & 0 & 4 & 4 & -1 \\
        %         3 & 9 & 0 & -1 & 1 \\
        %         4 & 9 & 7 & 0 & 2 \\
        %         2 & 7 & 5 & 4 & 0
        %     \end{pmatrix} \\
        %     L^{(4)} &= \begin{pmatrix}
        %         0 & 5 & 7 & 6 & 2 \\
        %         -3 & 0 & 4 & 3 & -1 \\
        %         3 & 8 & 0 & -1 & 1 \\
        %         4 & 9 & 7 & 0 & 2 \\
        %         2 & 7 & 5 & 4 & 0
        %     \end{pmatrix}
        % \end{align*}
        \item
        \begin{align*}
            L^{(1)} = 
            \begin{pmatrix}
                0 & 5 & \infty & \infty & 2 \\
                -3 & 0 & \infty & 4 & \infty \\
                4 & \infty & 0 & -1 & 7 \\
                \infty & \infty & \infty & 0 & 2 \\
                2 & \infty & 5 & \infty & 0
            \end{pmatrix}
            \,\,\,\,
            \pi^{(1)} = 
            \begin{pmatrix}
                n & 1 & n & n & 1 \\
                2 & n & n & 2 & n \\
                3 & n & n & 3 & 3 \\
                n & n & n & n & 4 \\
                5 & n & 5 & n & n
            \end{pmatrix}
            \\
            L^{(2)} = 
            \begin{pmatrix}
                0 & 5 & 7 & 9 & 2 \\
                -3 & 0 & \infty & 4 & -1 \\
                4 & 9 & 0 & -1 & 1 \\
                4 & \infty & 7 & 0 & 2 \\
                2 & 7 & 5 & 4 & 0
            \end{pmatrix}
            \,\,\,\,
            \pi^{(2)} = 
            \begin{pmatrix}
                n & 1 & 5 & 2 & 1 \\
                2 & n & n & 2 & 1 \\
                3 & 1 & n & 3 & 4 \\
                5 & n & 5 & n & 4 \\
                5 & 1 & 5 & 3 & n
            \end{pmatrix}
            \\
            L^{(4)} =
            \begin{pmatrix}
                0 & 5 & 7 & 6 & 2 \\
                -3 & 0 & 4 & 3 & -1 \\
                3 & 8 & 0 & -1 & 1 \\
                4 & 9 & 7 & 0 & 2 \\
                2 & 7 & 5 & 4 & 0
            \end{pmatrix}
            \,\,\,\,
            \pi^{(4)} =
            \begin{pmatrix}
                n & 1 & 5 & 3 & 1 \\
                2 & n & 5 & 3 & 1 \\
                5 & 1 & n & 3 & 4 \\
                5 & 1 & 5 & n & 4 \\
                5 & 1 & 5 & 3 & n
            \end{pmatrix}
            \\
        \end{align*}
        \item
        $L^{(n)}$ gibt die Länge kürzester Wege an, die maximal $n$ Kanten traversieren.
        Wenn der Graph keine negativen Zyklen enthält, sind alle kürzesten Wege maximal $|V| - 1$ Kanten lang, da alle Pfade mit mindestens $|V|$ Kanten einen Zyklus enthalten.
        Bei \textsc{FasterAPSP} wird $L^{(n)}$ mit $n = \min\{2^i \mid i \in \mathbb{N}, 2^i \geq |V| - 1\}$ bestimmt.
        Es gilt also $n \geq |V| - 1$.
        Daher sollte sich das Ergebnis nicht ändern, wenn man eine Iteration weiterrechnet.
        
        Anders sieht es aus, wenn der Graph negative Zyklen enthält.
        Dann kann es passieren, dass sich $L^{(n + 1)}$ von $L^{(n)}$ unterscheidet, da sich durch negative Zyklen kürzeste Wege verbessern, wenn mehr als $|V| - 1$ Kanten erlaubt werden.

        Tatsächlich kann man sogar zeigen, dass, wenn ein Graph negative Zyklen enthält, immer $L^{(n + 1)} \neq L^{(n)}$.
        Siehe dazu auch Bellman-Ford, wo ja auch nur ein weiterer Durchlauf zum Erkennen von negativen Zyklen genügt.
    \end{enumerate}
\end{loesung}

\begin{aufgabe}{2}{Floyd-Warshall-Algorithmus}
    \begin{enumerate}
        \item Bestimmen Sie $D$ und $\pi$ des Graphen $G_1$ mithilfe des Algorithmus von Floyd und Warshall.
        Geben Sie alle Zwischenschritte an.
        Markieren Sie dabei jeweils, welche Werte sich geändert haben.
        \item Angenommen, Sie führen den Floyd-Warshall-Algorithmus auf einem Graphen mit negativen Zyklen aus.
        Wie können Sie dies anhand der Ausgabe des Algorithmus erkennen?
        \item Angenommen, Sie modifizieren den Floyd-Warshall-Algorithmus, sodass die Matrix $L$ \emph{in-place} aktualisiert wird, anstatt für jeden Zwischenknoten eine neue Matrix anzulegen ($L^{(1)}, L^{(2)}, \ldots$).
        Begründen Sie, warum der Algorithmus weiterhin korrekt ist.
        % \item Es sei ein Graph $G = (V, E)$ gegeben.
        % Dann bezeichnet man den Graphen $G^* = (V, E')$ mit $E' = \{(u, v) \mid u \in V, v \in V, \text{$v$ ist von $u$ aus erreichbar}\}$ als transitive Hülle von $G$.
        % In $G^*$ kann man also anhand der Kanten sofort ablesen, welche Knoten in $G$ einander erreichen können.
        % Geben Sie einen Algorithmus mit Laufzeit $O(n^3)$ in Pseudocode an, der als Eingabe einen Graphen $G$ als Adjazenzmatrix erhält und $G^*$ (als Adjazenzmatrix) ausgibt.
    \end{enumerate}
\end{aufgabe}
\begin{loesung}
    \begin{enumerate}
        \item 
        \begin{align*}
            L^{(0)} = 
            \begin{pmatrix}
                0 & 5 & \infty & \infty & 2 \\
                -3 & 0 & \infty & 4 & \infty \\
                4 & \infty & 0 & -1 & 7 \\
                \infty & \infty & \infty & 0 & 2 \\
                2 & \infty & 5 & \infty & 0
            \end{pmatrix}
            \,\,\,\,
            \pi^{(0)} = 
            \begin{pmatrix}
                n & 1 & n & n & 1 \\
                2 & n & n & 2 & n \\
                3 & n & n & 3 & 3 \\
                n & n & n & n & 4 \\
                5 & n & 5 & n & n
            \end{pmatrix}
            \\
            L^{(1)} = 
            \begin{pmatrix}
                0 & 5 & \infty & \infty & 2 \\
                -3 & 0 & \infty & 4 & \mathbf{-1} \\
                4 & \mathbf{9} & 0 & -1 & \mathbf{6} \\
                \infty & \infty & \infty & 0 & 2 \\
                2 & \mathbf{7} & 5 & \infty & 0
            \end{pmatrix}
            \,\,\,\,
            \pi^{(1)} = 
            \begin{pmatrix}
                n & 1 & n & n & 1 \\
                2 & n & n & 2 & \mathbf{1} \\
                3 & \mathbf{1} & n & 3 & \mathbf{1} \\
                n & n & n & n & 4 \\
                5 & \mathbf{1} & 5 & n & n
            \end{pmatrix}
            \\
            L^{(2)} =
            \begin{pmatrix}
                0 & 5 & \infty & \mathbf{9} & 2 \\
                -3 & 0 & \infty & 4 & -1 \\
                4 & 9 & 0 & -1 & 6 \\
                \infty & \infty & \infty & 0 & 2 \\
                2 & 7 & 5 & \mathbf{11} & 0
            \end{pmatrix}
            \,\,\,\,
            \pi^{(2)} =
            \begin{pmatrix}
                n & 1 & n & \mathbf{2} & 1 \\
                2 & n & n & 2 & 1 \\
                3 & 1 & n & 3 & 1 \\
                n & n & n & n & 4 \\
                5 & 1 & 5 & \mathbf{2} & n
            \end{pmatrix}
            \\
            L^{(3)} =
            \begin{pmatrix}
                0 & 5 & \infty & 9 & 2 \\
                -3 & 0 & \infty & 4 & -1 \\
                4 & 9 & 0 & -1 & 6 \\
                \infty & \infty & \infty & 0 & 2 \\
                2 & 7 & 5 & \mathbf{4} & 0
            \end{pmatrix}
            \,\,\,\,
            \pi^{(3)} =
            \begin{pmatrix}
                n & 1 & n & 2 & 1 \\
                2 & n & n & 2 & 1 \\
                3 & 1 & n & 3 & 1 \\
                n & n & n & n & 4 \\
                5 & 1 & 5 & \mathbf{3} & n
            \end{pmatrix}
            \\
            L^{(4)} =
            \begin{pmatrix}
                0 & 5 & \infty & 9 & 2 \\
                -3 & 0 & \infty & 4 & -1 \\
                4 & 9 & 0 & -1 & \mathbf{1} \\
                \infty & \infty & \infty & 0 & 2 \\
                2 & 7 & 5 & 4 & 0
            \end{pmatrix}
            \,\,\,\,
            \pi^{(4)} =
            \begin{pmatrix}
                n & 1 & n & 2 & 1 \\
                2 & n & n & 2 & 1 \\
                3 & 1 & n & 3 & \mathbf{4} \\
                n & n & n & n & 4 \\
                5 & 1 & 5 & 3 & n
            \end{pmatrix}
            \\
            L^{(5)} =
            \begin{pmatrix}
                0 & 5 & \mathbf{7} & \mathbf{6} & 2 \\
                -3 & 0 & \mathbf{4} & \mathbf{3} & -1 \\
                \mathbf{3} & \mathbf{8} & 0 & -1 & 1 \\
                \mathbf{4} & \mathbf{9} & \mathbf{7} & 0 & 2 \\
                2 & 7 & 5 & 4 & 0
            \end{pmatrix}
            \,\,\,\,
            \pi^{(5)} =
            \begin{pmatrix}
                n & 1 & \mathbf{5} & \mathbf{3} & 1 \\
                2 & n & \mathbf{5} & \mathbf{3} & 1 \\
                \mathbf{5} & 1 & n & 3 & 4 \\
                \mathbf{5} & \mathbf{1} & \mathbf{5} & n & 4 \\
                5 & 1 & 5 & 3 & n
            \end{pmatrix}
            \\
        \end{align*}

        \item
        Wenn der Graph einen oder mehrere negative Zyklen enthält, ist dies an negativen Werten auf der Hauptdiagonale ($d_{ii}$) der Distanzmatrix $D$ zu erkennen.
        Die Werte der Hauptdiagonale von $D$ geben die Länge des kürzesten Weges von einem Knoten zu sich selbst an.
        Diese Länge sollte im Normalfall 0 sein.
        Ist sie jedoch negativ, ist dies nur durch einen negativen Zyklus möglich.
        Jeder (einfache) Zyklus durchläuft im schlimmsten Fall einmal alle Knoten, bevor er wieder beim Startpunkt ankommt, und umfasst somit maximal $|V|+1$ Knoten.
        Größere Zyklen lassen sich dabei immer in kleinere aufteilen.
        Bei so einem \quotes{maximalen} Zyklus sind alle Knoten bis auf den Start-/Zielknoten des Zyklus Zwischenknoten des Pfades.
        Da nach Abschluss von Floyd-Warshall alle Knoten als Zwischenknoten berücksichtigt wurden, muss ein negativer Zyklus, falls er existiert, in jedem Fall gefunden worden sein.
        \item
        Im Folgenden ist mit $D$ stets die Matrix des modifizierten \emph{in-place} Algorithmus gemeint, mit $D^{(k)}$ die Matrizen des Ursprungsalgorithmus.

        \emph{Behauptung:} Die Matrix $D$ ist nach der $k$-ten Iteration der äußeren Schleife identisch zu $D^{(k)}$.
        \begin{proof}
            Beweis durch Induktion:
            \begin{description}
                \item[IA:] Vor dem ersten Schleifendurchlauf gilt $D = D^{(0)} = W$.
                \item[IV:] Vor dem $k$-ten Schleifendurchlauf ist $D = D^{(k - 1)}$.
                \item[IS:] Um $d_{ij}^{(k)}$ zu bestimmen, werden die Werte $d_{ij}^{(k - 1)}$, $d_{ik}^{(k - 1)}$ und $d_{kj}^{(k - 1)}$ benötigt.
                Wenn also vor dem Setzen von $d_{ij}$ im $k$-ten Schleifendurchlauf die Werte $d_{ij}$, $d_{ik}$ und $d_{kj}$ unverändert im Vergleich zum vorherigen Durchlauf sind, wird $d_{ij}$ korrekt gesetzt.

                $d_{ij}$ ist trivialerweise unverändert, da es ja gerade erst gesetzt wird.
                $d_{ik}$ und $d_{kj}$ sind auch unverändert, da wir im aktuellen Durchlauf $k$ als Zwischenknoten betrachten. 
                Der Zwischenknoten $k$ hat nur dann Einfluss auf kürzeste Wege, die bei $k$ starten oder enden, wenn $k$ auf einem negativen Zyklus liegt.
                Dies haben wir aber per Definition bei Floyd-Warshall ausgeschlossen.
            \end{description}
            Nach dem Prinzip der Induktion ist $D$ nach dem $k$-ten Schleifendurchlauf für jedes $k$ identisch zu $D^{(k)}$.
        \end{proof}
        Dass der modifizierte Algorithmus korrekt ist, folgt sofort aus der Behauptung.
        % \item 
        % Setzt man die Gewichte $w(u, v) = 1$ für alle Kanten $(u, v) \in E$ fest und führt man den Floyd-Warshall-Algorithmus aus, kann man die Erreichbarkeit zwischen Knoten in der Matrix $D$ ablesen: $D_{ij} < \infty \Leftrightarrow \text{$j$ ist von $i$ aus erreichbar}$.
        % Wenn allerdings nur die Erreichbarkeit relevant ist und nicht der Abstand, kann man auch eine vereinfachte Variante von Floyd-Warshall nutzen, die auf das Relaxieren komplett verzichtet wird und in den Matrizen $D^{(k)}$ nur die Erreichbarkeit und nicht der Abstand gespeichert wird:
        % \begin{algorithmic}[1]
        %     \Procedure{TransitiveClosure}{$V, E$}
        %         \State $D \gets E$
        %         \For{$i \gets 1 \text{ \textbf{to} } |V|$}
        %             \State $d_{ii} \gets 1$ \Comment{Jeder Knoten kann sich selbst erreichen}
        %         \EndFor
        %         \For{$k \in V$}
        %             \For{$i \gets 1 \text{ \textbf{to} } |V|$}
        %                 \For{$j \gets 1 \text{ \textbf{to} } |V|$}
        %                     \State $d_{ij} \gets d_{ij} \vee (d_{ik} \wedge d_{kj})$
        %                     \Comment{Update: Ist $j$ von $i$ über $k$ erreichbar?}
        %                 \EndFor
        %             \EndFor
        %         \EndFor
        %         \State \Return $D$
        %     \EndProcedure
        % \end{algorithmic}
    \end{enumerate}
\end{loesung}

\ifcsdef{showLoesung}{}{\newpage}
\begin{aufgabe}{3}{Dynamische Programmierung}
    Gegeben sei ein Array $(a_1, a_2, \ldots, a_n)$ mit $a_i \in \mathbb{Z}$ für $1 \leq i \leq n$.
    Eine aufsteigende Subsequenz des Arrays ist definiert als eine Folge $s_1, s_2, \ldots, s_{k - 1}, s_k$ mit $1 \leq s_1 < s_2 < \ldots < s_k \leq n$ und $a_{s_1} < a_{s_2} < \ldots < a_{s_k}$.
    Gesucht ist die längste, aufsteigende Subsequenz.
    \begin{description}
        \item[Beispiel:] Eingabe: $(7, 12, 4, 8, 6, 8, 9, 8, 11)$ $\rightarrow$ Ausgabe: $(3, 5, 6, 7, 9)$ mit $k = 5$. Dies entspricht den Elementen~$(4, 6, 8, 9, 11)$ des Arrays.
    \end{description}
    \begin{enumerate}[label=\alph*)]
        \item\label{optimal_substructure} Beschreiben Sie kurz, inwiefern die längste, aufsteigende Subsequenz die Eigenschaften einer optimalen Substruktur besitzt.
        \item\label{dynamic} Implementieren Sie einen Algorithmus in Pseudocode oder einer Programmiersprache Ihrer Wahl mit Laufzeit $O(n^2)$ nach dem Prinzip der dynamischen Programmierung, welcher ein Array $a$ als Eingabe erhält und $k$ ausgibt.
        Dabei ist $k$ die Länge der längsten, aufsteigenden Subsequenz $s_1, \ldots, s_k$.
        \begin{description}
            \item[Tipp:] Berechnen Sie für jedes $i$ ($1 \leq i \leq n$) die Länge der längsten, aufsteigenden Subsequenz die bei $a_i$ endet ($s_k = i$) und geben Sie abschießend das Maximum dieser Werte zurück.
        \end{description}
        \item Erweitern Sie Ihren Algorithmus, sodass dieser neben der Länge $k$ der Sequenz $a_{s_1}, a_{s_2}, \ldots, a_{s_k}$ auch die Sequenz selbst ausgibt.
        Die Laufzeit soll weiterhin $O(n^2)$ betragen.
        \item
        Formulieren Sie obiges Problem als Graphproblem.
        Interpretieren Sie hierfür die Werte des Arrays als Knoten eines Graphen.
        Ziehen Sie sie von $a_i$ nach $a_j$ immer dann eine Kante, wenn $i < j$ und $a_i < a_j$.
        Nennen Sie einen Algorithmus aus der Vorlesung, mit dem Sie entsprechende Graphproblem lösen können.
    \end{enumerate}
\end{aufgabe}
\begin{loesung}
    \begin{enumerate}
        \item Es sei eine längste, aufsteigende Subsequenz $s_1, s_2, \ldots, s_i, \ldots, s_j, \ldots, s_{k - 1}, s_k$ gegeben.
        Nun wird die Teilsequenz $s_i, s_{i + 1}, \ldots s_{j - 1}, s_j$ betrachtet.
        Diese Teilsequenz ist eine längste, aufsteigende Subsequenz des Teilarrays $a_{s_i}, a_{s_i + 1}, \ldots, a_{s_j - 1}, a_{s_j}$ unter den Nebenbedingungen, dass $a_{s_{i - 1}} < a_{s_i}$ und $a_{s_j} < a_{s_{j + 1}}$.
        Gäbe es nämlich eine längere, aufsteigende Subsequenz in diesem Teilarray unter obigen Nebenbedingungen, könnte man diese (analog zum Beweis der optimalen Substruktur kürzester Wege) in die ursprüngliche, längste, aufsteigende Subsequenz $s_1, \ldots, s_k$ einsetzen und diese damit verlängern.

        Man kann das betrachtete Teilarray sogar auf $a_{s_{i - 1} + 1}, a_{s_{i - 1} + 2}, \ldots a_{s_i}, \ldots, a_{s_j}, \ldots, a_{s_{j + 1} - 2}, a_{s_{j + 1} - 1}$ ausweiten.
        $s_i, \ldots, s_j$ ist im erweitereten Teilarray weiterhin eine längste, aufsteigende Subsequenz (unter besagten Nebenbedigungen).

        \item 
        Das Array $a$ wird von links nach rechts durchlaufen. Für jedes Element $a_i$ wird die Länge $l_i$ der längsten, aufsteigenden Subsequenz bestimmt, die bei $a_i$ endet (siehe Tipp).
        Diese Längen werden in einem temporären Array gespeichert.
        Um $l_i$ zu bestimmen, können so die Längen bei allen vorherigen Elemente ($l_1, l_2, \ldots, l_{i-1}$) verwendet werden.
        
        Für die längste, aufsteigende Subsequenz, die bei $a_i$ endet, gibt es zwei Möglichkeiten:
        Entweder enthält sie nur das Element $a_i$ und besitzt somit Länge 1.
        Oder sie ist länger.
        In diesem Fall enthält sie zusätzlich weitere Elemente aus der Menge $\{a_1, a_2, \ldots, a_{i - 1}\}$.
        Seien dies die Elemente $(a_{s_1}, a_{s_2}, \ldots, a_{s_l})$.
        Aufgrund der Eigentschaften aufsteigender Subsequenzen gilt dann $1 \leq s_1 < s_2 < \ldots < s_l < i$ sowie außerdem $a_{s_1} < a_{s_2} < \ldots < a_{s_l} < a_i$.
        Da längste, aufsteigende Subsequenzen gemäß Teilaufgabe~\ref*{optimal_substructure} eine optimale Substruktur bilden, muss $s_1, s_2, \ldots, s_l$ die längste, aufsteigende Subsequenz im Bereich $[1, i - 1]$ sein unter der zusätzlichen Einschränkung, dass $a_{s_l} < a_i$.

        Die Länge $l$ dieser Subsequenz entspricht $\max\{l_j \mid j \in \{1, 2, \ldots, i - 1\}, a_j < a_i\}$.
        Es gilt dann also $l_i = l + 1$.
        Für jedes $i$ kann man $l_i$ leicht bestimmen, indem man über alle $l_1, l_2, \ldots, l_{i - 1}$ iteriert und das Maximium aller $l_j$ bestimmt, für die $a_j < a_i$ gilt.
        
        Nachdem man alle $l_i$ bestimmt hat, muss man nur noch $k = \max\{l_i | i \in \{1, 2, \ldots, n\}\}$ ausgeben.
        \begin{lstlisting}[language=c++]
int longestIncreasingSubsequence(int a[], int n) {
    int *seqLen = new int[n];
    int k = 1;
    for (int i = 0; i < n; i++) {
        seqLen[i] = 1;
    }
    for (int i = 1; i < n; i++) {
        for (int j = 0; j < i; j++) {
            if (a[j] < a[i]) {
                seqLen[i] = max(seqLen[i], seqLen[j] + 1);
                k = max(k, seqLen[i]);
            }
        }
    }
    return k;
} 
        \end{lstlisting}
        Die Laufzeit wird dominiert durch die beiden verschachtelten \texttt{for}-Schleifen.
        Deren Laufzeit ergibt sich durch die Gaußsumme: $\Theta(n^2)$.
        \item Jedes Mal, wenn ein $l_i$ aktualisiert wird, muss zusätzlich gespeichert werden welches $a_j$ ($1 \leq j < i$) vor $a_i$ in der längsten, bei $a_i$ endenden, aufsteigenden Subsequenz steht.
        Dies geschiet im Beispeilcode unten mithilfe des Hilfsarrays \texttt{prev}.
        Jedes Mal, wenn man eine neue, längste, aufsteigende Subsequenz findet ($l_i > k$), aktualisiert man nicht nur $k$, sondern merkt sich auch das $i$, bei dem das $k$ erreicht wurde.
        Auf diese Weise kennt man, nachdem alle $l_i$ bestimmt wurden, die Endposition der längsten, aufsteigenden Subsequenz.
        Außerdem kann man mittels \texttt{prev} die gesamte Sequenz von hinten nach vorne rekonstruieren.
        \begin{lstlisting}[language=c++]
int longestIncreasingSubsequenceExt(int a[], int n, int **pSolution) {
    int *seqLen = new int[n];
    int *prev = new int[n];
    int k = 1;
    int kIndex = 0;
    for (int i = 0; i < n; i++) {
        seqLen[i] = 1;
        prev[i] = -1;
    }
    for (int i = 1; i < n; i++) {
        for (int j = 0; j < i; j++) {
            if (a[j] < a[i] && seqLen[j] + 1 > seqLen[i]) {
                seqLen[i] = seqLen[j] + 1;
                prev[i] = j;
                if (seqLen[i] > k) {
                    k = seqLen[i];
                    kIndex = i;
                }
            }
        }
    }
    int *solution = new int[k];
    int j = kIndex;
    for (int i = k - 1; i >= 0; i--) {
        solution[i] = a[j];
        j = prev[j];
    }
    *pSolution = solution;
    return k;
}
        \end{lstlisting}
        Im Wesentlichen kommt im Vergleich zum Ursprungsalgorithmus eine weitere \texttt{for}-Schleife hinzu, die $k \leq n = O(n)$ Iterationen durchläuft.
        Die Laufzeit $O(n^2)$ ändert sich also nicht.

        \item Wird ein Graph gemäß der Aufgabenstellung erstellt, entspricht jeder Pfad zwischen zwei Knoten im Graphen einer aufsteigenden Subsequenz.
        Die längste, aufsteigende Subsequenz entspricht daher dem längsten Pfad im Graphen.
        Diesen längsten Pfad kann man beispielsweise mittels Floyd-Warshall finden.
        Dafür legt man für alle $(u, v) \in E$ das Kantengewicht $w(u, v) = -1$ fest.
        Anschließend sucht man alle kürzesten Wege im Graphen mittels Floyd-Warshall. Der kürzeste Weg gemäß obiger Gewichte entspricht dem längsten Weg nach Kantenanzahl und somit der längsten, aufsteigenden Subsequenz.
        Negative Zyklen kann es nicht geben, da Kanten nur von kleinen zu großen Arrayindezes existieren (siehe Bedingung $i < j$) und der Graph somit azyklisch ist.
        Die Laufzeit von Floyd-Warshall wäre mit $O(n^3)$ schlechter als die des in den letzten beiden Teilaufgaben entwickelten Algorithmus ($O(n^2)$).
    \end{enumerate}
\end{loesung}

\ifcsdef{volbert}{}{
\begin{aufgabe}{4}{Lernen regulärer Sprachen: $\mathrm{L}^*$, $\mathrm{NL}^*$}
    Gegeben sei die Sprache $L$ über dem Alphabet $\Sigma = \{a, b\}$, die durch den regulären Ausdruck $(a|b)^*ab(a|b)$ definiert ist.
    \begin{enumerate}
        \item Bestimmen die einen minimalen DEA $M$ mit $\mathcal{L}(M) = L$ mithilfe des Algorithmus $\mathrm{L}^*$. Geben Sie alle Zwischenschritte an (Herstellen von Geschlossenheit und Konsistenz, Äquivalenzfragen, Gegenbeispiele).
        \item Bestimmen den kanonischen RFSA $M$ mit $\mathcal{L}(M) = L$ mithilfe des Algorithmus $\mathrm{NL}^*$. Geben Sie alle Zwischenschritte an (Herstellen von Geschlossenheit und Konsistenz, Äquivalenzfragen, Gegenbeispiele).
        \item Bestimmen Sie, zunächst von Hand, den (minimalen) DEA, der das Muster $abba$ in einem Text ($\Sigma = \{a, b\}$) sucht.
        Überprüfen Sie Ihr Ergebnis, indem Sie den Automaten mittels $\mathrm{L}^*$ erlernen.
        \item Angenommen, Sie haben einen DEA $M = (Q, q_0, \delta, F)$ und ein Wort $w \in \Sigma^*$ gegeben.
        Beschreiben Sie mittels Pseudocode, wie Sie überprüfen können, ob $w \in \mathcal{L}(M)$. Geben Sie Laufzeit und Speicherbedarf Ihres Algorithmus in $O$-Notation an, abhängig von $n = |Q|$ und $m = |w|$.
        \begin{description}
            \item[Hinweis:] Das Auswerten von $\delta(q, w_i)$ für einen Zustand $q$ und ein Zeichen des Wortes $w_i$ benötigt konstante Laufzeit.
            Ebenso kann man in $O(1)$ bestimmen, ob $q \in F$.
        \end{description}
        \item Angenommen, Sie haben stattdessen einen NEA $M = (Q, Q_0, \delta, F)$ gegeben.
        Geben Sie einen Algorithmus in Pseudocode an, der für ein Wort $w \in \Sigma^*$ prüft, ob $w \in \mathcal{L}(M)$.
        Welche Laufzeit und Speicherbedarf besitzt Ihr Algorithmus?
    \end{enumerate}
\end{aufgabe}
}

\ifcsdef{showLoesung}{\ifcsdef{volbert}{}{
\begin{loesung}
    \begin{enumerate}
        \item Wir initialisieren die Tabelle:
        \begin{table}[h!]
            \centering
            \begin{tabular}{c|c}
                & $\epsilon$ \\
                \hline
                $\epsilon$ & $-$ \\
                \hline
                $a$ & $-$ \\
                $b$ & $-$ \\
            \end{tabular}
        \end{table}
        \FloatBarrier
        Die Tabelle ist geschlossen und konsistent.
        Jedoch bildet der resultierende Automat
        \begin{figure*}[h!]
            \centering
            \begin{tikzpicture}[scale=0.15]
            \tikzstyle{every node}+=[inner sep=0pt]
            \draw [black] (27.4,-22) circle (3);
            \draw (27.4,-22) node {$-$};
            \draw [black] (26.077,-19.32) arc (234:-54:2.25);
            \draw (27.4,-14.75) node [above] {$a,b$};
            \fill [black] (28.72,-19.32) -- (29.6,-18.97) -- (28.79,-18.38);
            \draw [black] (21.7,-22) -- (24.4,-22);
            \fill [black] (24.4,-22) -- (23.6,-21.5) -- (23.6,-22.5);
            \end{tikzpicture}
        \end{figure*}
        \FloatBarrier
        nicht die gewünschte Sprache ab. So sollte das Gegenbeispiel $aba$ in der Sprache enthalten sein.
        Also erweitern wir die Tabelle:
        \begin{table}[h!]
            \centering
            \begin{tabular}{c|c}
                & $\epsilon$ \\
                \hline
                $\epsilon$ & $-$ \\
                $a$ & $-$ \\
                $ab$ & $-$ \\
                $aba$ & $+$ \\
                \hline
                $b$ & $-$ \\
                $aa$ & $-$ \\
                $abb$ & $+$ \\
                $abaa$ & $-$ \\
                $abab$ & $-$ \\
            \end{tabular}
        \end{table}
        \FloatBarrier
        Die Tabelle ist geschlossen, aber nicht konsistent (die Präfixe $\epsilon$ und $ab$ mit Folgezeichen $a$ in Spalte $\epsilon$):
        \begin{table}[h!]
            \centering
            \begin{tabular}{c|cc}
                & $\epsilon$ & $a$ \\
                \hline
                $\epsilon$ & $-$ & $-$ \\
                $a$ & $-$ & $-$ \\
                $ab$ & $-$ & $+$ \\
                $aba$ & $+$ & $-$ \\
                \hline
                $b$ & $-$ & $-$ \\
                $aa$ & $-$ & $-$ \\
                $abb$ & $+$ & $-$ \\
                $abaa$ & $-$ & $-$ \\
                $abab$ & $-$ & $+$ \\
            \end{tabular}
        \end{table}
        \FloatBarrier
        Die Tabelle ist geschlossen, aber nicht konsistent (die Präfixe $\epsilon$ und $a$ mit Folgezeichen $b$ in Spalte $a$):
        \begin{table}[h!]
            \centering
            \begin{tabular}{c|ccc}
                & $\epsilon$ & $a$ & $ba$ \\
                \hline
                $\epsilon$ & $-$ & $-$ & $-$ \\
                $a$ & $-$ & $-$ & $+$ \\
                $ab$ & $-$ & $+$ & $-$ \\
                $aba$ & $+$ & $-$ & $+$ \\
                \hline
                $b$ & $-$ & $-$ & $-$ \\
                $aa$ & $-$ & $-$ & $+$ \\
                $abb$ & $+$ & $-$ & $-$ \\
                $abaa$ & $-$ & $-$ & $+$ \\
                $abab$ & $-$ & $+$ & $-$ \\
            \end{tabular}
        \end{table}
        \FloatBarrier
        Die Tabelle ist nicht geschlossen (Präfix $abb$):
        \begin{table}[h!]
            \centering
            \begin{tabular}{c|ccc}
                & $\epsilon$ & $a$ & $ba$ \\
                \hline
                $\epsilon$ & $-$ & $-$ & $-$ \\
                $a$ & $-$ & $-$ & $+$ \\
                $ab$ & $-$ & $+$ & $-$ \\
                $aba$ & $+$ & $-$ & $+$ \\
                $abb$ & $+$ & $-$ & $-$ \\
                \hline
                $b$ & $-$ & $-$ & $-$ \\
                $aa$ & $-$ & $-$ & $+$ \\
                $abaa$ & $-$ & $-$ & $+$ \\
                $abab$ & $-$ & $+$ & $-$ \\
                $abba$ & $-$ & $-$ & $+$ \\
                $abbb$ & $-$ & $-$ & $-$ \\
            \end{tabular}
        \end{table}
        \FloatBarrier
        Diese Tabelle ist geschlossen und konsistent.
        Der resultierende Automat
        \begin{figure*}[h!]
            \centering
            \begin{tikzpicture}[scale=0.23]
            \tikzstyle{every node}+=[inner sep=0pt]
            \draw [black] (28.8,-23.9) circle (3);
            \draw (28.8,-23.9) node {$---$};
            \draw [black] (42,-23.9) circle (3);
            \draw (42,-23.9) node {$--+$};
            \draw [black] (53.1,-23.9) circle (3);
            \draw (53.1,-23.9) node {$-+-$};
            \draw [black] (66.9,-17.7) circle (3);
            \draw (66.9,-17.7) node {$+-+$};
            \draw [black] (66.9,-17.7) circle (2.4);
            \draw [black] (66.9,-31.2) circle (3);
            \draw (66.9,-31.2) node {$+--$};
            \draw [black] (66.9,-31.2) circle (2.4);
            \draw [black] (23.5,-23.9) -- (25.8,-23.9);
            \fill [black] (25.8,-23.9) -- (25,-23.4) -- (25,-24.4);
            \draw [black] (31.8,-23.9) -- (39,-23.9);
            \fill [black] (39,-23.9) -- (38.2,-23.4) -- (38.2,-24.4);
            \draw (35.4,-24.4) node [below] {$a$};
            \draw [black] (27.477,-21.22) arc (234:-54:2.25);
            \draw (28.8,-16.65) node [above] {$b$};
            \fill [black] (30.12,-21.22) -- (31,-20.87) -- (30.19,-20.28);
            \draw [black] (40.677,-21.22) arc (234:-54:2.25);
            \draw (42,-16.65) node [above] {$a$};
            \fill [black] (43.32,-21.22) -- (44.2,-20.87) -- (43.39,-20.28);
            \draw [black] (45,-23.9) -- (50.1,-23.9);
            \fill [black] (50.1,-23.9) -- (49.3,-23.4) -- (49.3,-24.4);
            \draw (47.55,-24.4) node [below] {$b$};
            \draw [black] (55.342,-21.91) arc (127.41217:100.97425:20.572);
            \fill [black] (63.92,-18.05) -- (63.04,-17.72) -- (63.23,-18.7);
            \draw (58.48,-18.98) node [above] {$a$};
            \draw [black] (55.75,-25.3) -- (64.25,-29.8);
            \fill [black] (64.25,-29.8) -- (63.77,-28.98) -- (63.31,-29.87);
            \draw (59.01,-28.05) node [below] {$b$};
            \draw [black] (44.264,-21.935) arc (127.568:80.39618:25.387);
            \fill [black] (44.26,-21.93) -- (45.2,-21.84) -- (44.59,-21.05);
            \draw (52.93,-16.86) node [above] {$a$};
            \draw [black] (64.477,-19.467) arc (-56.804:-74.80958:29.589);
            \fill [black] (56.03,-23.26) -- (56.93,-23.53) -- (56.67,-22.57);
            \draw (61.38,-22.21) node [below] {$b$};
            \draw [black] (63.922,-31.554) arc (-86.12599:-126.5534:29.567);
            \fill [black] (44.32,-25.81) -- (44.66,-26.68) -- (45.26,-25.88);
            \draw (52.83,-30.98) node [below] {$a$};
            \draw [black] (64.129,-32.346) arc (-70.12983:-131.56313:33.067);
            \fill [black] (30.95,-25.99) -- (31.22,-26.89) -- (31.88,-26.15);
            \draw (46.14,-34.31) node [below] {$b$};
            \end{tikzpicture}
        \end{figure*}
        \FloatBarrier
        bildet die gewünschte Sprache ab.
        Fertig!
        \item Wir initialisieren die Tabelle:
        \begin{table}[h!]
            \centering
            \begin{tabular}{c|c}
                & $\epsilon$ \\
                \hline
                $\epsilon$ & $-$ \\
                \hline
                $a$ & $-$ \\
                $b$ & $-$ \\
            \end{tabular}
        \end{table}
        \FloatBarrier
        Die Tabelle ist geschlossen und konsistent.
        Jedoch bildet der resultierende Automat
        \begin{figure*}[h!]
            \centering
            \begin{tikzpicture}[scale=0.15]
            \tikzstyle{every node}+=[inner sep=0pt]
            \draw [black] (27.4,-22) circle (3);
            \draw (27.4,-22) node {$-$};
            \draw [black] (26.077,-19.32) arc (234:-54:2.25);
            \draw (27.4,-14.75) node [above] {$a,b$};
            \fill [black] (28.72,-19.32) -- (29.6,-18.97) -- (28.79,-18.38);
            \draw [black] (21.7,-22) -- (24.4,-22);
            \fill [black] (24.4,-22) -- (23.6,-21.5) -- (23.6,-22.5);
            \end{tikzpicture}
        \end{figure*}
        \FloatBarrier
        nicht die gewünschte Sprache ab. So sollte das Gegenbeispiel $aba$ in der Sprache enthalten sein.
        Also erweitern wir die Tabelle:
        \begin{table}[h!]
            \centering
            \begin{tabular}{c|cccc}
                & $\epsilon$ & $a$ & $ba$ & $aba$ \\
                \hline
                $\epsilon$ & $-$ & $-$ & $-$ & $+$ \\
                \hline
                $a$ & $-$ & $-$ & $+$ & $+$ \\
                $b$ & $-$ & $-$ & $-$ & $+$ \\
            \end{tabular}
        \end{table}
        \FloatBarrier
        Die Tabelle ist nicht geschlossen (Präfix $a$):
        \begin{table}[h!]
            \centering
            \begin{tabular}{c|cccc}
                & $\epsilon$ & $a$ & $ba$ & $aba$ \\
                \hline
                $\epsilon$ & $-$ & $-$ & $-$ & $+$ \\
                $a$ & $-$ & $-$ & $+$ & $+$ \\
                \hline
                $b$ & $-$ & $-$ & $-$ & $+$ \\
                $aa$ & $-$ & $-$ & $+$ & $+$ \\
                $ab$ & $-$ & $+$ & $-$ & $+$ \\
            \end{tabular}
        \end{table}
        \FloatBarrier
        Die Tabelle ist nicht geschlossen (Präfix $ab$):
        \begin{table}[h!]
            \centering
            \begin{tabular}{c|cccc}
                & $\epsilon$ & $a$ & $ba$ & $aba$ \\
                \hline
                $\epsilon$ & $-$ & $-$ & $-$ & $+$ \\
                $a$ & $-$ & $-$ & $+$ & $+$ \\
                $ab$ & $-$ & $+$ & $-$ & $+$ \\
                \hline
                $b$ & $-$ & $-$ & $-$ & $+$ \\
                $aa$ & $-$ & $-$ & $+$ & $+$ \\
                $aba$ & $+$ & $-$ & $+$ & $+$ \\
                $abb$ & $+$ & $-$ & $-$ & $+$ \\
            \end{tabular}
        \end{table}
        \FloatBarrier
        Die Tabelle ist nicht geschlossen ($aba$ ist keine Primzeile, aber $abb$):
        \begin{table}[h!]
            \centering
            \begin{tabular}{c|cccc}
                & $\epsilon$ & $a$ & $ba$ & $aba$ \\
                \hline
                $\epsilon$ & $-$ & $-$ & $-$ & $+$ \\
                $a$ & $-$ & $-$ & $+$ & $+$ \\
                $ab$ & $-$ & $+$ & $-$ & $+$ \\
                $abb$ & $+$ & $-$ & $-$ & $+$ \\
                \hline
                $b$ & $-$ & $-$ & $-$ & $+$ \\
                $aa$ & $-$ & $-$ & $+$ & $+$ \\
                $aba$ & $+$ & $-$ & $+$ & $+$ \\
                $abba$ & $-$ & $-$ & $+$ & $+$ \\
                $abbb$ & $-$ & $-$ & $-$ & $+$ \\
            \end{tabular}
        \end{table}
        \FloatBarrier
        Diese Tabelle ist geschlossen und konsistent.
        Der resultierende Automat
        \begin{figure*}[h!]
            \centering
            \begin{tikzpicture}[scale=0.25]
            \tikzstyle{every node}+=[inner sep=0pt]
            \draw [black] (15,-23.1) circle (3);
            \draw (15,-23.1) node {$---+$};
            \draw [black] (35.5,-23.1) circle (3);
            \draw (35.5,-23.1) node {$--++$};
            \draw [black] (15,-40.9) circle (3);
            \draw (15,-40.9) node {$-+-+$};
            \draw [black] (35.5,-40.9) circle (3);
            \draw (35.5,-40.9) node {\tiny $+--+$};
            \draw [black] (35.5,-40.9) circle (2.4);
            \draw [black] (10,-23.1) -- (12,-23.1);
            \fill [black] (12,-23.1) -- (11.2,-22.6) -- (11.2,-23.6);
            \draw [black] (18,-23.1) -- (32.5,-23.1);
            \fill [black] (32.5,-23.1) -- (31.7,-22.6) -- (31.7,-23.6);
            \draw (25.25,-23.6) node [below] {$a$};
            \draw [black] (12.487,-21.484) arc (264.98525:-23.01475:2.25);
            \draw (9.83,-16.81) node [above] {$a,b$};
            \fill [black] (14.75,-20.12) -- (15.32,-19.37) -- (14.33,-19.28);
            \draw [black] (15,-37.9) -- (15,-26.1);
            \fill [black] (15,-26.1) -- (14.5,-26.9) -- (15.5,-26.9);
            \draw (14.5,-32) node [left] {$a,b$};
            \draw [black] (17.609,-21.626) arc (114.764:65.236:18.242);
            \fill [black] (17.61,-21.63) -- (18.54,-21.74) -- (18.13,-20.84);
            \draw (25.25,-19.45) node [above] {$a,b$};
            \draw [black] (34.023,-43.505) arc (-35.59913:-226.33596:14.229);
            \fill [black] (12.63,-24.93) -- (11.7,-25.12) -- (12.39,-25.84);
            \draw (11.42,-46.46) node [below] {$a,b$};
            \draw [black] (35.5,-37.9) -- (35.5,-26.1);
            \fill [black] (35.5,-26.1) -- (35,-26.9) -- (36,-26.9);
            \draw (36,-32) node [right] {$a$};
            \draw [black] (18,-40.9) -- (32.5,-40.9);
            \fill [black] (32.5,-40.9) -- (31.7,-40.4) -- (31.7,-41.4);
            \draw (25.25,-41.4) node [below] {$a,b$};
            \draw [black] (34.177,-20.42) arc (234:-54:2.25);
            \draw (35.5,-15.85) node [above] {$a$};
            \fill [black] (36.82,-20.42) -- (37.7,-20.07) -- (36.89,-19.48);
            \draw [black] (16.713,-38.438) arc (143.43977:118.49531:49.392);
            \fill [black] (16.71,-38.44) -- (17.59,-38.09) -- (16.79,-37.5);
            \draw (22.99,-30.07) node [above] {$b$};
            \draw [black] (33.58,-25.405) arc (-40.93176:-57.13316:75.322);
            \fill [black] (33.58,-25.41) -- (32.68,-25.68) -- (33.43,-26.34);
            \draw (27.01,-33.42) node [below] {$a$};
            \end{tikzpicture}
        \end{figure*}
        \FloatBarrier
        bildet die gewünschte Sprache ab.
        Das ist einfacher zu sehen, wenn man sich klar macht, dass man das Wort von vorne beliebig verlängern kann und es immer noch Teil der Sprache ist.
        Das bedeuetet, dass man einige Transitionen entfernen kann, ohne die Sprache zu verändern.
        \begin{figure*}[h!]
            \centering
            \begin{tikzpicture}[scale=0.25]
            \draw [black] (15,-23.1) circle (3);
            \draw (15,-23.1) node {$---+$};
            \draw [black] (35.5,-23.1) circle (3);
            \draw (35.5,-23.1) node {$--++$};
            \draw [black] (15,-40.9) circle (3);
            \draw (15,-40.9) node {$-+-+$};
            \draw [black] (35.5,-40.9) circle (3);
            \draw (35.5,-40.9) node {\tiny $+--+$};
            \draw [black] (35.5,-40.9) circle (2.4);
            \draw [black] (10,-23.1) -- (12,-23.1);
            \fill [black] (12,-23.1) -- (11.2,-22.6) -- (11.2,-23.6);
            \draw [black] (18,-23.1) -- (32.5,-23.1);
            \fill [black] (32.5,-23.1) -- (31.7,-22.6) -- (31.7,-23.6);
            \draw (25.25,-23.6) node [below] {$a$};
            \draw [black] (12.487,-21.484) arc (264.98525:-23.01475:2.25);
            \draw (9.83,-16.81) node [above] {$a,b$};
            \fill [black] (14.75,-20.12) -- (15.32,-19.37) -- (14.33,-19.28);
            \draw [black] (18,-40.9) -- (32.5,-40.9);
            \fill [black] (32.5,-40.9) -- (31.7,-40.4) -- (31.7,-41.4);
            \draw (25.25,-41.4) node [below] {$a,b$};
            \draw [black] (33.23,-25.07) -- (17.27,-38.93);
            \fill [black] (17.27,-38.93) -- (18.2,-38.79) -- (17.54,-38.03);
            \draw (24.24,-31.51) node [above] {$b$};
            \end{tikzpicture}
        \end{figure*}
        \FloatBarrier
        \item Der folgende Automat erkennt Vorkommnisse des Wortes $abba$.
        \begin{figure*}[h!]
            \centering
            \begin{tikzpicture}[scale=0.15]
                \tikzstyle{every node}+=[inner sep=0pt]
                \draw [black] (14.2,-19.6) circle (3);
                \draw (14.2,-19.6) node {$0$};
                \draw [black] (23.6,-19.6) circle (3);
                \draw (23.6,-19.6) node {$1$};
                \draw [black] (32.9,-19.6) circle (3);
                \draw (32.9,-19.6) node {$2$};
                \draw [black] (42.5,-19.6) circle (3);
                \draw (42.5,-19.6) node {$3$};
                \draw [black] (52,-19.6) circle (3);
                \draw (52,-19.6) node {$4$};
                \draw [black] (52,-19.6) circle (2.4);
                \draw [black] (8.4,-19.6) -- (11.2,-19.6);
                \fill [black] (11.2,-19.6) -- (10.4,-19.1) -- (10.4,-20.1);
                \draw [black] (17.2,-19.6) -- (20.6,-19.6);
                \fill [black] (20.6,-19.6) -- (19.8,-19.1) -- (19.8,-20.1);
                \draw (18.9,-19.1) node [above] {$a$};
                \draw [black] (26.6,-19.6) -- (29.9,-19.6);
                \fill [black] (29.9,-19.6) -- (29.1,-19.1) -- (29.1,-20.1);
                \draw (28.25,-19.1) node [above] {$b$};
                \draw [black] (35.9,-19.6) -- (39.5,-19.6);
                \fill [black] (39.5,-19.6) -- (38.7,-19.1) -- (38.7,-20.1);
                \draw (37.7,-19.1) node [above] {$b$};
                \draw [black] (45.5,-19.6) -- (49,-19.6);
                \fill [black] (49,-19.6) -- (48.2,-19.1) -- (48.2,-20.1);
                \draw (47.25,-19.1) node [above] {$a$};
                \draw [black] (12.877,-16.92) arc (234:-54:2.25);
                \draw (14.2,-12.35) node [above] {$b$};
                \fill [black] (15.52,-16.92) -- (16.4,-16.57) -- (15.59,-15.98);
                \draw [black] (21.159,-17.876) arc (262.5036:-25.4964:2.25);
                \draw (19.44,-13.17) node [above] {$a$};
                \fill [black] (23.48,-16.61) -- (24.08,-15.89) -- (23.09,-15.76);
                \draw [black] (30.978,-21.847) arc (-57.47803:-122.52197:5.075);
                \fill [black] (25.52,-21.85) -- (25.93,-22.7) -- (26.47,-21.86);
                \draw (28.25,-23.14) node [below] {$a$};
                \draw [black] (40.328,-21.665) arc (-50.96462:-129.03538:19.019);
                \fill [black] (16.37,-21.66) -- (16.68,-22.56) -- (17.31,-21.78);
                \draw (28.35,-26.41) node [below] {$b$};
                \draw [black] (25.3,-17.133) arc (140.14712:39.85288:16.283);
                \fill [black] (25.3,-17.13) -- (26.2,-16.84) -- (25.43,-16.2);
                \draw (37.8,-10.78) node [above] {$a$};
                \draw [black] (35.107,-17.578) arc (125.67421:54.32579:12.592);
                \fill [black] (35.11,-17.58) -- (36.05,-17.52) -- (35.46,-16.71);
                \draw (42.45,-14.72) node [above] {$b$};
            \end{tikzpicture}
        \end{figure*}
        \FloatBarrier
        Wir überprüfen den Automat mittels $\mathrm{L}^*$.
        Dazu initialisieren wir zunächst die Tabelle:
        \begin{table}[h!]
            \centering
            \begin{tabular}{c|c}
                & $\epsilon$ \\
                \hline
                $\epsilon$ & $-$ \\
                \hline
                $a$ & $-$ \\
                $b$ & $-$ \\
            \end{tabular}
        \end{table}
        \FloatBarrier
        Die Tabelle ist geschlossen und konsistent.
        Jedoch bildet der resultierende Automat
        \begin{figure*}[h!]
            \centering
            \begin{tikzpicture}[scale=0.15]
            \tikzstyle{every node}+=[inner sep=0pt]
            \draw [black] (27.4,-22) circle (3);
            \draw (27.4,-22) node {$-$};
            \draw [black] (26.077,-19.32) arc (234:-54:2.25);
            \draw (27.4,-14.75) node [above] {$a,b$};
            \fill [black] (28.72,-19.32) -- (29.6,-18.97) -- (28.79,-18.38);
            \draw [black] (21.7,-22) -- (24.4,-22);
            \fill [black] (24.4,-22) -- (23.6,-21.5) -- (23.6,-22.5);
            \end{tikzpicture}
        \end{figure*}
        \FloatBarrier
        nicht die gewünschte Sprache ab. So sollte das Gegenbeispiel $abba$ in der Sprache enthalten sein.
        Also erweitern wir die Tabelle:
        \begin{table}[h!]
            \centering
            \begin{tabular}{c|c}
                & $\epsilon$ \\
                \hline
                $\epsilon$ & $-$ \\
                $a$ & $-$ \\
                $ab$ & $-$ \\
                $abb$ & $-$ \\
                $abba$ & $+$ \\
                \hline
                $b$ & $-$ \\
                $aa$ & $-$ \\
                $aba$ & $-$ \\
                $abbb$ & $-$ \\
                $abbaa$ & $-$ \\
                $abbab$ & $-$ \\
            \end{tabular}
        \end{table}
        \FloatBarrier
        Die Tabelle ist geschlossen, aber nicht konsistent (die Präfixe $ab$ und $abb$ mit Folgezeichen $a$ in Spalte $\epsilon$):
        \begin{table}[h!]
            \centering
            \begin{tabular}{c|cc}
                & $\epsilon$ & $a$ \\
                \hline
                $\epsilon$ & $-$ & $-$ \\
                $a$ & $-$ & $-$ \\
                $ab$ & $-$ & $-$ \\
                $abb$ & $-$ & $+$ \\
                $abba$ & $+$ & $-$ \\
                \hline
                $b$ & $-$ & $-$ \\
                $aa$ & $-$ & $-$ \\
                $aba$ & $-$ & $-$ \\
                $abbb$ & $-$ & $-$ \\
                $abbaa$ & $-$ & $-$ \\
                $abbab$ & $-$ & $-$ \\
            \end{tabular}
        \end{table}
        \FloatBarrier
        Die Tabelle ist geschlossen, aber nicht konsistent (die Präfixe $a$ und $ab$ mit Folgezeichen $b$ in Spalte $a$):
        \begin{table}[h!]
            \centering
            \begin{tabular}{c|ccc}
                & $\epsilon$ & $a$ & $ba$ \\
                \hline
                $\epsilon$ & $-$ & $-$ & $-$ \\
                $a$ & $-$ & $-$ & $-$ \\
                $ab$ & $-$ & $-$ & $+$ \\
                $abb$ & $-$ & $+$ & $-$ \\
                $abba$ & $+$ & $-$ & $-$ \\
                \hline
                $b$ & $-$ & $-$ & $-$ \\
                $aa$ & $-$ & $-$ & $-$ \\
                $aba$ & $-$ & $-$ & $-$ \\
                $abbb$ & $-$ & $-$ & $-$ \\
                $abbaa$ & $-$ & $-$ & $-$ \\
                $abbab$ & $-$ & $-$ & $+$ \\
            \end{tabular}
        \end{table}
        \FloatBarrier
        Die Tabelle ist geschlossen, aber nicht konsistent (die Präfixe $\epsilon$ und $a$ mit Folgezeichen $b$ in Spalte $ba$):
        \begin{table}[h!]
            \centering
            \begin{tabular}{c|cccc}
                & $\epsilon$ & $a$ & $ba$ & $bba$ \\
                \hline
                $\epsilon$ & $-$ & $-$ & $-$ & $-$ \\
                $a$ & $-$ & $-$ & $-$ & $+$ \\
                $ab$ & $-$ & $-$ & $+$ & $-$ \\
                $abb$ & $-$ & $+$ & $-$ & $-$ \\
                $abba$ & $+$ & $-$ & $-$ & $+$ \\
                \hline
                $b$ & $-$ & $-$ & $-$ & $-$ \\
                $aa$ & $-$ & $-$ & $-$ & $+$ \\
                $aba$ & $-$ & $-$ & $-$ & $+$ \\
                $abbb$ & $-$ & $-$ & $-$ & $-$ \\
                $abbaa$ & $-$ & $-$ & $-$ & $+$ \\
                $abbab$ & $-$ & $-$ & $+$ & $-$ \\
            \end{tabular}
        \end{table}
        \FloatBarrier
        Diese Tabelle ist geschlossen und konsistent.
        Der entsprechende Automat
        \begin{figure*}[h!]
            \centering
            \begin{tikzpicture}[scale=0.25]
                \tikzstyle{every node}+=[inner sep=0pt]
                \draw [black] (14.2,-19.6) circle (3);
                \draw (14.2,-19.6) node {$----$};
                \draw [black] (23.6,-19.6) circle (3);
                \draw (23.6,-19.6) node {$---+$};
                \draw [black] (32.9,-19.6) circle (3);
                \draw (32.9,-19.6) node {$--+-$};
                \draw [black] (42.5,-19.6) circle (3);
                \draw (42.5,-19.6) node {$-+--$};
                \draw [black] (52,-19.6) circle (3);
                \draw (52,-19.6) node {\tiny $+--+$};
                \draw [black] (52,-19.6) circle (2.4);
                \draw [black] (8.4,-19.6) -- (11.2,-19.6);
                \fill [black] (11.2,-19.6) -- (10.4,-19.1) -- (10.4,-20.1);
                \draw [black] (17.2,-19.6) -- (20.6,-19.6);
                \fill [black] (20.6,-19.6) -- (19.8,-19.1) -- (19.8,-20.1);
                \draw (18.9,-19.1) node [above] {$a$};
                \draw [black] (26.6,-19.6) -- (29.9,-19.6);
                \fill [black] (29.9,-19.6) -- (29.1,-19.1) -- (29.1,-20.1);
                \draw (28.25,-19.1) node [above] {$b$};
                \draw [black] (35.9,-19.6) -- (39.5,-19.6);
                \fill [black] (39.5,-19.6) -- (38.7,-19.1) -- (38.7,-20.1);
                \draw (37.7,-19.1) node [above] {$b$};
                \draw [black] (45.5,-19.6) -- (49,-19.6);
                \fill [black] (49,-19.6) -- (48.2,-19.1) -- (48.2,-20.1);
                \draw (47.25,-19.1) node [above] {$a$};
                \draw [black] (12.877,-16.92) arc (234:-54:2.25);
                \draw (14.2,-12.35) node [above] {$b$};
                \fill [black] (15.52,-16.92) -- (16.4,-16.57) -- (15.59,-15.98);
                \draw [black] (21.159,-17.876) arc (262.5036:-25.4964:2.25);
                \draw (19.44,-13.17) node [above] {$a$};
                \fill [black] (23.48,-16.61) -- (24.08,-15.89) -- (23.09,-15.76);
                \draw [black] (30.978,-21.847) arc (-57.47803:-122.52197:5.075);
                \fill [black] (25.52,-21.85) -- (25.93,-22.7) -- (26.47,-21.86);
                \draw (28.25,-23.14) node [below] {$a$};
                \draw [black] (40.328,-21.665) arc (-50.96462:-129.03538:19.019);
                \fill [black] (16.37,-21.66) -- (16.68,-22.56) -- (17.31,-21.78);
                \draw (28.35,-26.41) node [below] {$b$};
                \draw [black] (25.3,-17.133) arc (140.14712:39.85288:16.283);
                \fill [black] (25.3,-17.13) -- (26.2,-16.84) -- (25.43,-16.2);
                \draw (37.8,-10.78) node [above] {$a$};
                \draw [black] (35.107,-17.578) arc (125.67421:54.32579:12.592);
                \fill [black] (35.11,-17.58) -- (36.05,-17.52) -- (35.46,-16.71);
                \draw (42.45,-14.72) node [above] {$b$};
            \end{tikzpicture}
        \end{figure*}
        \FloatBarrier
        bildet die gewünschte Sprache ab.
        Fertig!

        \item 
        Es genügt, den aktuellen Zustand $q$ des Automats zu speichern (initialisiert mit $q_0$).
        Das Wort $w$ wird Zeichen für Zeichen eingelesen und $q$ gemäß $\delta$ aktualisiert.
        Nachdem das Wort gelesen wurde, muss nur überprüft werden, ob $q \in F$.
        \begin{algorithmic}[1]
            \Procedure{IsInLanguage}{$(Q, q_0, \delta, F), w$}
                \State $q \gets q_0$
                \For{$i \gets 1 \text{ \textbf{to} } |w|$}
                    \State $q \gets \delta(q, w_i)$
                \EndFor
                \State \Return $q \in F$
            \EndProcedure
        \end{algorithmic}
        Die Laufzeit wird dominiert von der \texttt{for}-Schleife, die insgesamt $m$ Iterationen durchläuft.
        Die Laufzeit ist also $O(m)$.
        Nur der aktuelle Zustand muss temporär zwischengespeichert werden.
        Der Speicherbedarf ist also $O(1)$.
        \item 
        Es wird die Menge der Zustände $\hat{q}$ gespeichert, in der sich der Automat zum aktuellen Zeitpunkt befinden kann.
        $\hat{q}$ wird zu Beginn mit der Menge der Startzustände $Q_0$ initialisiert.
        Anschließend wird $\hat{q}$ für jedes Zeichen $w_i$ des Wortes aktualisiert, indem $\delta(q, w_i)$ für jeden Zustand $q \in \hat{q}$ bestimmt wird und alle resultierenden Mengen vereinigt werden.
        Wenn nach dem Lesen des Wortes mindestens ein Zustand in $\hat{q}$ in $F$ liegt, wird das Wort akzeptiert.
        \begin{algorithmic}[1]
            \Procedure{IsInLanguage}{$(Q, q_0, \delta, F), w$}
                \State $\hat{q} \gets q_0$
                \For{$i \gets 1 \text{ \textbf{to} } |w|$}
                    \State $\hat{q}' \gets \varnothing$
                    \For{$q \in \hat{q}$}
                        \State $\hat{q}' \gets \hat{q} \cup \delta(q, w_i)$
                    \EndFor
                    \State $\hat{q} \gets \hat{q}'$
                \EndFor
                \For{$q \in \hat{q}$}
                    \If{$q \in F$}
                        \State \Return \textbf{true}
                    \EndIf
                \EndFor
                \State \Return \textbf{false}
            \EndProcedure
        \end{algorithmic}
        Die Laufzeit des Algorithmus hängt von der konkreten Darstellung der Menge $\hat{q}$ ab.
        Gehen wir davon aus, dass $\hat{q}$ durch ein Array $a$ von $n$ Booleans repräsentiert wird, sodass der $a_i$ angibt, ob $q_i \in \hat{q}$ (Das gleiche gilt für $\hat{q}'$).
        Eine alternative Darstellung wäre eine Hashtabelle. Die Laufzeit ändert sich jedoch in diesem Fall nicht wesentlich.

        Betrachten wir für zunächst die erste \texttt{for}-Schleife.
        Die äußere Schleife durchläuft $m$ Iterationen.
        Für die innere Schleife wird einmal $a$ durchlaufen und alle Zustände betrachtet, die in $\hat{q}$ enthalten sind.
        Das Durchlaufen der Schleife benötigt also jedes Mal Laufzeit $O(n)$.
        Wie lange benötigt allerdings Zeile 6?
        Wir implementieren das Vereinigen, indem wir alle Elemente von $\delta(q, w_i)$ durchlaufen und jedes Mal den entsprechenden Boolean-Wert des Arrays auf \emph{wahr} setzen.
        Die Laufzeit hängt also von der Größe von $\delta(q, w_i)$ ab.
        Da $\delta(q, w_i) \subseteq Q$, beträgt die Laufzeit $O(n)$.
        Die Laufzeit für die gesamte erste \texttt{for}-Schleife ist also $O(m \cdot n \cdot n) = O(m n^2)$.

        Die zweite Schleife, die überprüft, ob der Automat in einem Endzustand landet, benötigt Laufzeit $O(n)$, da laut Angabe $q \in F$ in $O(1)$ bestimmbar ist.
        Die Gesamtlaufzeit des Algorithmus ist also $O(mn^2)$.

        Der Algorithmus speichert $\hat{q}$ und $\hat{q}'$ temporär.
        Beide werden durch Arrays der Länge $n$ repräsentiert.
        Der Speicherbedarf ist also $O(n)$.
    \end{enumerate}
\end{loesung}
}}

\end{document}