\documentclass[11pt,a4paper]{article}

\usepackage{gastex}
\usepackage{etoolbox}
% \newcommand{\showLoesung}{2} %<---als Schalter
% \newcommand{\showInhalt}{1} %<---als Schalter

\input{../skel/uebmacsPNG}

\usepackage{enumitem}
\usepackage{algpseudocode}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{placeins}
\usepackage{multicol}
\usepackage{slashbox}
\usepackage{fancyvrb}
\usepackage{ulem}
\usepackage{amssymb}

\begin{document}
\thispagestyle{empty}
\DeclareRobustCommand{\ttfamily}{\fontencoding{T1}\fontfamily{lmtt}\selectfont}

\newcommand{\quotes}[1]{\glqq{}#1\grqq{}}

\Uebung{12}{13}{Simon Thelen}{20. Januar 2021}  % FIXME: Blattnummer, Datum, Zeit

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\ifcsdef{showLoesung}{
\textbf{Bitte beachten Sie:} Die Lösungen können trotz sorgfältiger Prüfung Fehler enthalten.
Bei Fragen oder Unklarheiten kontaktieren Sie bitte den Tutor oder Dozenten in Tutorien, Übungen oder nach Vorlesungen.
}{}

\begin{aufgabe}{1}{APSP}
    Gegeben sei der Graph $G$:
    \begin{figure}[h!]
        \centering
        \begin{tikzpicture}[scale=0.15]
            \tikzstyle{every node}+=[inner sep=0pt]
            \draw [black] (25.6,-17.5) circle (3);
            \draw (25.6,-17.5) node {$a$};
            \draw [black] (51.7,-17.5) circle (3);
            \draw (51.7,-17.5) node {$b$};
            \draw [black] (25.6,-40.1) circle (3);
            \draw (25.6,-40.1) node {$c$};
            \draw [black] (51.7,-40.1) circle (3);
            \draw (51.7,-40.1) node {$d$};
            \draw [black] (38.8,-28.2) circle (3);
            \draw (38.8,-28.2) node {$e$};
            \draw [black] (28.213,-18.972) arc (58.55225:43.39089:41.986);
            \fill [black] (36.82,-25.95) -- (36.63,-25.02) -- (35.91,-25.71);
            \draw (33.75,-21.68) node [above] {$2$};
            \draw [black] (28.567,-17.055) arc (97.43418:82.56582:77.932);
            \fill [black] (48.73,-17.05) -- (48,-16.46) -- (47.88,-17.45);
            \draw (38.65,-15.9) node [above] {$5$};
            \draw [black] (48.77,-18.144) arc (-79.18957:-100.81043:53.958);
            \fill [black] (28.53,-18.14) -- (29.22,-18.79) -- (29.41,-17.8);
            \draw (38.65,-19.6) node [below] {$-3$};
            \draw [black] (36.872,-30.498) arc (-41.61193:-54.31779:53.459);
            \fill [black] (28.08,-38.42) -- (29.03,-38.36) -- (28.44,-37.55);
            \draw (33.71,-35.19) node [below] {$5$};
            \draw [black] (28.6,-40.1) -- (48.7,-40.1);
            \fill [black] (48.7,-40.1) -- (47.9,-39.6) -- (47.9,-40.6);
            \draw (38.65,-40.6) node [below] {$-1$};
            \draw [black] (49.49,-38.07) -- (41.01,-30.23);
            \fill [black] (41.01,-30.23) -- (41.25,-31.14) -- (41.93,-30.41);
            \draw (46.27,-33.66) node [above] {$2$};
            \draw [black] (51.7,-20.5) -- (51.7,-37.1);
            \fill [black] (51.7,-37.1) -- (52.2,-36.3) -- (51.2,-36.3);
            \draw (51.2,-28.8) node [left] {$4$};
            \draw [black] (27.371,-37.68) arc (141.43987:122.6304:36.412);
            \fill [black] (36.21,-29.71) -- (35.27,-29.72) -- (35.81,-30.56);
            \draw (30.45,-32.84) node [above] {$7$};
            \draw [black] (36.174,-26.752) arc (-121.03069:-137.02618:39.844);
            \fill [black] (27.56,-19.77) -- (27.74,-20.7) -- (28.47,-20.01);
            \draw (30.62,-24.06) node [below] {$2$};
            \draw [black] (25.6,-37.1) -- (25.6,-20.5);
            \fill [black] (25.6,-20.5) -- (25.1,-21.3) -- (26.1,-21.3);
            \draw (26.1,-28.8) node [right] {$4$};
        \end{tikzpicture}
    \end{figure}
    \FloatBarrier
    \begin{enumerate}
        \item Geben Sie die Distanzmatrix $D$ von $G$ an.
        \item Finden Sie alle kürzesten Wege innerhalb des Graphen mithilfe des Algorithmus \textsc{APSP}.
        Geben Sie nach jedem Schritt die Matrix $L$ an.
        \item Finden Sie alle kürzesten Wege innerhalb des Graphen mithilfe des Algorithmus \textsc{FasterAPSP}
        Geben Sie nach jedem Schritt die Matrix $L$ an.
        \item Wie muss \textsc{APSP} erweitert werden, sodass neben der Distanzmatrix $D$ auch die Vorgängermatrix $\pi$ korrekt bestimmt wird.
        % \item Erweitern Sie \textsc{APSP}, sodass der Algorithmus zusätzlich erkennt, ob der Graph negative Zyklen enthält.
        % \begin{description}
        %     \item[Tipp:] Wenn ein Pfad $P$ von $v$ zu $v$ existiert mit $w(P) < 0$, liegt $v$ auf einem negativen Zyklus.
        % \end{description}
    \end{enumerate}
\end{aufgabe}

\begin{aufgabe}{2}{Floyd-Warshall-Algorithmus}
    \begin{enumerate}
        \item Bestimmen Sie $D$ und $\pi$ des Graphen $G$ mithilfe des Algorithmus von Floyd und Warshall.
        \item Angenommen, Sie wenden Floyd-Warshall auf einen Graphen mit negativen Zyklen an.
        Wie können Sie dies anhand der Ausgabe des Algorithmus erkennen?
        \item Angenommen, Sie modifizieren Floyd-Warshall, sodass er die Matrix $L$ \emph{in-place} aktualisiert, anstatt für jeden Zwischenknoten eine neue Matrix anzulegen ($L^{(1)}, L^{(2)}, \ldots$).
        Begründen, warum der Algorithmus weiterhin korrekt ist.
        \item Sei der Graph $G = (V, E)$ gegeben.
        Dann bezeichnet man den Graphen $G^* = (V, E')$ mit $E' = \{(u, v) \mid u \in V, v \in V, \text{$v$ ist von $u$ aus erreichbar}\}$ als transitive Hülle von $G$.
        In $G^*$ kann man also anhand der Kanten sofort ablesen, welche Knoten in $G$ einander erreichen können.
        Geben Sie einen Algorithmus mit Laufzeit $O(n^3)$ in Pseudocode an, der als Eingabe einen Graphen $G$ als Adjazenzmatrix erhält und $G^*$ bestimmt.
    \end{enumerate}
\end{aufgabe}

\begin{aufgabe}{3}{Dynamische Programmierung}
    Gegeben sei ein Array $(a_1, a_2, \ldots, a_n)$ mit $a_i \in \mathbb{Z}$ für $1 \leq i \leq n$.
    Eine aufsteigende Subsequenz des Arrays ist definiert als eine Folge $s_1, s_2, \ldots, s_{k - 1}, s_k$ mit $1 \leq s_1 < s_2 < \ldots < s_k \leq n$ und $a_{s_1} < a_{s_2} < \ldots < a_{s_k}$.
    Gesucht ist die längste, aufsteigende Subsequenz.
    \begin{description}
        \item[Beispiel:] Eingabe: $(7, 12, 4, 8, 6, 8, 9, 8, 11)$ $\rightarrow$ Ausgabe: $(3, 5, 6, 7, 9)$ mit $k = 5$. Dies entspricht den Elementen~$(4, 6, 8, 9, 11)$ des Arrays.
    \end{description}
    \begin{enumerate}[label=\alph*)]
        \item\label{optimal_substructure} Beschreiben Sie kurz, inwiefern die längste, aufsteigende Subsequenz die Eigenschaften einer optimalen Substruktur besitzt.
        \item\label{dynamic} Implementieren Sie einen Algorithmus in Pseudocode oder einer Programmiersprache Ihrer Wahl mit Laufzeit $O(n^2)$ nach dem Prinzip der dynamischen Programmierung, welcher ein Array $a$ als Eingabe erhält und $k$ ausgibt, die Länge der längsten, aufsteigenden Subsequenz $s_1, \ldots, s_k$.
        \begin{description}
            \item[Tipp:] Berechnen Sie für jedes $i$ ($1 \leq i \leq n$) die Länge der längsten, aufsteigenden Subsequenz die bei $a_i$ endet ($s_k = i$) und geben Sie abschießend das Maximum dieser Werte zurück.
        \end{description}
        \item Erweitern Sie Ihren Algorithmus, sodass dieser neben der Länge $k$ der Sequenz $a_{s_1}, a_{s_2}, \ldots, a_{s_k}$ auch die Sequenz selbst ausgibt.
        Die Laufzeit soll weiterhin $O(n^2)$ betragen.
        \item
        Formulieren Sie obiges Problem als Graphproblem.
        Interpretieren Sie hierfür die Werte des Arrays als Knoten eines Graphen.
        Ziehen Sie sie von $a_i$ nach $a_j$ immer dann eine Kante, wenn $i < j$ und $a_i < a_j$.
        Nennen Sie einen Algorithmus aus der Vorlesung, mit dem Sie entsprechende Graphproblem lösen können.
    \end{enumerate}
\end{aufgabe}
\begin{loesung}
    \begin{enumerate}
        \item Es sei eine längste, aufsteigende Subsequenz $s_1, s_2, \ldots, s_i, \ldots, s_j, \ldots, s_{k - 1}, s_k$ gegeben.
        Nun wird die Teilsequenz $s_i, s_{i + 1}, \ldots s_{j - 1}, s_j$ betrachtet.
        Diese Teilsequenz ist eine längste, aufsteigende Subsequenz des Teilarrays $a_{s_i}, a_{s_i + 1}, \ldots, a_{s_j - 1}, a_{s_j}$ unter den Nebenbedingungen, dass $a_{s_{i - 1}} < a_{s_i}$ und $a_{s_j} < a_{s_{j + 1}}$.
        Gäbe es nämlich eine längere, aufsteigende Subsequenz in diesem Teilarray unter obigen Nebenbedingungen, könnte man diese (analog zum Beweis der optimalen Substruktur kürzester Wege) in die ursprüngliche, längste, aufsteigende Subsequenz $s_1, \ldots, s_k$ einsetzen und diese damit verlängern.

        Man kann das betrachtete Teilarray sogar auf $a_{s_{i - 1} + 1}, a_{s_{i - 1} + 2}, \ldots a_{s_i}, \ldots, a_{s_j}, \ldots, a_{s_{j + 1} - 2}, a_{s_{j + 1} - 1}$ ausweiten.
        $s_i, \ldots, s_j$ ist im erweitereten Teilarray weiterhin eine längste, aufsteigende Subsequenz (unter besagten Nebenbedigungen).

        \item 
        Das Array $a$ wird von links nach rechts durchlaufen. Für jedes Element $a_i$ wird die Länge $l_i$ der längsten, aufsteigenden Subsequenz bestimmt, die bei $a_i$ endet (siehe Tipp).
        Diese Längen werden in einem temporären Array gespeichert.
        Um $l_i$ zu bestimmen, können so die Längen bei allen vorherigen Elemente ($l_1, l_2, \ldots, l_{i-1}$) verwendet werden.
        
        Für die längste, aufsteigende Subsequenz, die bei $a_i$ endet, gibt es zwei Möglichkeiten:
        Entweder enthält sie nur das Element $a_i$ und besitzt somit Länge 1.
        Oder sie ist länger.
        In diesem Fall enthält sie zusätzlich weitere Elemente aus der Menge $\{a_1, a_2, \ldots, a_{i - 1}\}$.
        Seien dies die Elemente $(a_{s_1}, a_{s_2}, \ldots, a_{s_l})$.
        Aufgrund der Eigentschaften aufsteigender Subsequenzen gilt dann $1 \leq s_1 < s_2 < \ldots < s_l < i$ sowie außerdem $a_{s_1} < a_{s_2} < \ldots < a_{s_l} < a_i$.
        Da längste, aufsteigende Subsequenzen eine optimale Substruktur bilden (siehe Teilaufgabe \ref*{optimal_substructure}), muss $s_1, s_2, \ldots, s_l$ die längste, aufsteigende Subsequenz im Bereich $[1, i - 1]$ sein unter der zusätzlichen Einschränkung, dass $a_{s_l} < a_i$.

        Die Länge $l$ dieser Subsequenz entspricht $\max\{l_j \mid j \in \{1, 2, \ldots, i - 1\}, a_j < a_i\}$.
        Es gilt dann also $l_i = l + 1$.
        Für jedes $i$ kann man also $l_i$ leicht bestimmen, indem man über alle $l_1, l_2, \ldots, l_{i - 1}$ iteriert und das Maximium aller $l_j$ bestimmt, für die $a_j < a_i$ gilt.
        Schließlich muss man nur noch $k = \max\{l_i | i \in \{1, 2, \ldots, n\}\}$ bestimmen.
        \begin{lstlisting}[language=c++]
int longestIncreasingSubsequence(int a[], int n) {
    int *seqLen = new int[n];
    int k = 1;
    for (int i = 0; i < n; i++) {
        seqLen[i] = 1;
    }
    for (int i = 1; i < n; i++) {
        for (int j = 0; j < i; j++) {
            if (a[j] < a[i]) {
                seqLen[i] = max(seqLen[i], seqLen[j] + 1);
                k = max(k, seqLen[i]);
            }
        }
    }
    return k;
} 
        \end{lstlisting}
        Die Laufzeit wird dominiert durch die beiden verschachtelten \texttt{for}-Schleifen.
        Deren Laufzeit ergibt sich durch die Gaußsumme: $\Theta(n^2)$.
        \item Jedes Mal, wenn ein $l_i$ aktualisiert wird, muss zusätzlich gespeichert werden welches $a_j$ ($1 \leq j < i$) vor $a_i$ in der längsten, bei $a_i$ endenden, aufsteigenden Subsequenz steht.
        Dies geschiet im Beispeilcode unten mithilfe des Hilfsarrays \texttt{prev}.
        Jedes Mal, wenn man eine neue, längste, aufsteigende Subsequenz findet ($l_i > k$), aktualisiert man nicht nur $k$, sondern merkt sich auch das $i$, bei dem das $k$ erreicht wurde.
        Auf diese Weise kennt man, nachdem alle $l_i$ bestimmt wurden, die Endposition der längsten, aufsteigenden Subsequenz.
        Außerdem kann man mittels \texttt{prev} die gesamte Sequenz von hinten nach vorne rekonstruieren.
        \begin{lstlisting}[language=c++]
int longestIncreasingSubsequenceExt(int a[], int n, int **solP) {
    int *seqLen = new int[n];
    int *prev = new int[n];
    int k = 1;
    int kIndex = 0;
    for (int i = 0; i < n; i++) {
        seqLen[i] = 1;
        prev[i] = -1;
    }
    for (int i = 1; i < n; i++) {
        for (int j = 0; j < i; j++) {
            if (a[j] < a[i] && seqLen[j] + 1 > seqLen[i]) {
                seqLen[i] = seqLen[j] + 1;
                prev[i] = j;
                if (seqLen[i] > k) {
                    k = seqLen[i];
                    kIndex = i;
                }
            }
        }
    }
    int *sol = new int[k];
    int j = kIndex;
    for (int i = k - 1; i >= 0; i--) {
        sol[i] = a[j];
        j = prev[j];
    }
    *solP = sol;
    return k;
}
        \end{lstlisting}
        Im Wesentlichen kommt im Vergleich zum Ursprungsalgorithmus eine weitere \texttt{for}-Schleife hinzu, die $k \leq n = O(n)$ Iterationen durchläuft.
        Die Laufzeit $O(n^2)$ ändert sich also nicht.

        \item Wird ein Graph gemäß der Aufgabenstellung erstellt, entspricht jeder Pfad zwischen zwei Knoten im Graphen einer aufsteigenden Subsequenz.
        Die längste, aufsteigende Subsequenz entspricht daher dem längsten Pfad im Graphen.
        Diesen längsten Pfad kann man beispielsweise mittels Floyd-Warshall finden.
        Dafür legt man für alle $(u, v) \in E$ das Kantengewicht $w(u, v) = -1$ fest.
        Anschließend sucht man alle kürzesten Wege im Graphen mittels Floyd-Warshall. Der kürzeste Weg gemäß obiger Gewichte entspricht dem längsten Weg nach Kantenanzahl und somit der längsten, aufsteigenden Subsequenz.
        Negative Zyklen kann es nicht geben, da Kanten nur von kleinen zu großen Arrayindezes existieren (siehe Bedingung $i < j$) und der Graph somit azyklisch ist.
        Die Laufzeit von Floyd-Warshall wäre mit $O(n^3)$ schlechter als die des in den letzten beiden Teilaufgaben entwickelten Algorithmus ($O(n^2)$).
    \end{enumerate}
\end{loesung}

\begin{aufgabe}{4}{Lernen regulärer Sprachen: $\mathrm{L}^*$, $\mathrm{NL}^*$}
    Gegeben sei die Sprache $L$ über dem Alphabet $\Sigma = \{a, b\}$, die durch den regulären Ausdruck $(a|b)^*ab(a|b)$ definiert ist. $L$ enthält also genau die Wörter, die auf $aba$ oder $abb$ enden.
    \begin{enumerate}
        \item Bestimmen die einen minimalen DEA $M$ mit $\mathcal{L}(M) = L$ mithilfe des Algorithmus $\mathrm{L}^*$. Geben Sie alle Zwischenschritte an (Herstellen von Geschlossenheit und Konsistenz, Äquivalenzfragen).
        \item Bestimmen den kanonischen RFSA $M$ mit $\mathcal{L}(M) = L$ mithilfe des Algorithmus $\mathrm{NL}^*$. Geben Sie alle Zwischenschritte an (Herstellen von Geschlossenheit und Konsistenz, Äquivalenzfragen).
        \item Angenommen, Sie haben einen DEA $M = (Q, q_0, \delta, F)$ und ein Wort $w$ gegeben.
        Beschreiben Sie mittels Pseudocode, wie Sie überprüfen können, ob $w \in \mathcal{L}(M)$. Geben Sie Laufzeit und Speicherbedarf Ihres Algorithmus an, abhängig von $n = |Q|$ und $m = |w|$.
        \begin{description}
            \item[Hinweis:] Das Berechnen von $\delta$ und das Bestimmen, ob $q \in F$, benötigt nur konstante Laufzeit.
        \end{description}
        \item Angenommen, Sie haben stattdessen einen NEA $M = (Q, Q_0, \delta, F)$ gegeben.
        Wie können Sie dann für ein Wort $w$ prüfen, ob $w \in \mathcal{L}(M)$?
        Geben Sie erneut Zeit- und Speicherbedarf an.
    \end{enumerate}
\end{aufgabe}

\end{document}