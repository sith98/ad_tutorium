\documentclass[11pt,a4paper]{article}

\usepackage{gastex}
\usepackage{etoolbox}
\newcommand{\showLoesung}{2} %<---als Schalter
% \newcommand{\showInhalt}{1} %<---als Schalter

\input{../skel/uebmacsPNG}

\usepackage{enumitem}
\usepackage{algpseudocode}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{placeins}
\usepackage{multicol}
\usepackage{slashbox}
\usepackage{fancyvrb}
\usepackage{ulem}
\usepackage{amssymb}

\begin{document}
\thispagestyle{empty}
\DeclareRobustCommand{\ttfamily}{\fontencoding{T1}\fontfamily{lmtt}\selectfont}

\newcommand{\quotes}[1]{\glqq{}#1\grqq{}}

\Uebung{12}{13}{Simon Thelen}{20. Januar 2021}  % FIXME: Blattnummer, Datum, Zeit

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\ifcsdef{showLoesung}{
\textbf{Bitte beachten Sie:} Die Lösungen können trotz sorgfältiger Prüfung Fehler enthalten.
Bei Fragen oder Unklarheiten kontaktieren Sie bitte den Tutor oder Dozenten in Tutorien, Übungen oder nach Vorlesungen.
}{}

\begin{aufgabe}{1}{\textnormal{\textsc{APSP}} und \textnormal{\textsc{FasterAPSP}}}
    Gegeben sei der Graph $G_1$:
    \begin{figure}[h!]
        \centering
        \begin{tikzpicture}[scale=0.15]
            \tikzstyle{every node}+=[inner sep=0pt]
            \draw [black] (25.6,-17.5) circle (3);
            \draw (25.6,-17.5) node {$a$};
            \draw [black] (51.7,-17.5) circle (3);
            \draw (51.7,-17.5) node {$b$};
            \draw [black] (25.6,-40.1) circle (3);
            \draw (25.6,-40.1) node {$c$};
            \draw [black] (51.7,-40.1) circle (3);
            \draw (51.7,-40.1) node {$d$};
            \draw [black] (38.8,-28.2) circle (3);
            \draw (38.8,-28.2) node {$e$};
            \draw [black] (28.213,-18.972) arc (58.55225:43.39089:41.986);
            \fill [black] (36.82,-25.95) -- (36.63,-25.02) -- (35.91,-25.71);
            \draw (33.75,-21.68) node [above] {$2$};
            \draw [black] (28.567,-17.055) arc (97.43418:82.56582:77.932);
            \fill [black] (48.73,-17.05) -- (48,-16.46) -- (47.88,-17.45);
            \draw (38.65,-15.9) node [above] {$5$};
            \draw [black] (48.77,-18.144) arc (-79.18957:-100.81043:53.958);
            \fill [black] (28.53,-18.14) -- (29.22,-18.79) -- (29.41,-17.8);
            \draw (38.65,-19.6) node [below] {$-3$};
            \draw [black] (36.872,-30.498) arc (-41.61193:-54.31779:53.459);
            \fill [black] (28.08,-38.42) -- (29.03,-38.36) -- (28.44,-37.55);
            \draw (33.71,-35.19) node [below] {$5$};
            \draw [black] (28.6,-40.1) -- (48.7,-40.1);
            \fill [black] (48.7,-40.1) -- (47.9,-39.6) -- (47.9,-40.6);
            \draw (38.65,-40.6) node [below] {$-1$};
            \draw [black] (49.49,-38.07) -- (41.01,-30.23);
            \fill [black] (41.01,-30.23) -- (41.25,-31.14) -- (41.93,-30.41);
            \draw (46.27,-33.66) node [above] {$2$};
            \draw [black] (51.7,-20.5) -- (51.7,-37.1);
            \fill [black] (51.7,-37.1) -- (52.2,-36.3) -- (51.2,-36.3);
            \draw (51.2,-28.8) node [left] {$4$};
            \draw [black] (27.371,-37.68) arc (141.43987:122.6304:36.412);
            \fill [black] (36.21,-29.71) -- (35.27,-29.72) -- (35.81,-30.56);
            \draw (30.45,-32.84) node [above] {$7$};
            \draw [black] (36.174,-26.752) arc (-121.03069:-137.02618:39.844);
            \fill [black] (27.56,-19.77) -- (27.74,-20.7) -- (28.47,-20.01);
            \draw (30.62,-24.06) node [below] {$2$};
            \draw [black] (25.6,-37.1) -- (25.6,-20.5);
            \fill [black] (25.6,-20.5) -- (25.1,-21.3) -- (26.1,-21.3);
            \draw (26.1,-28.8) node [right] {$4$};
        \end{tikzpicture}
    \end{figure}
    \FloatBarrier
    \begin{enumerate}
        \item Geben Sie die Distanzmatrix $D$ von $G_1$ an.
        \item Finden Sie alle kürzesten Wege in $G_1$ mithilfe des Algorithmus \textsc{APSP}.
        Geben Sie nach jedem Schritt die Matrix $L$ an.
        \item Finden Sie alle kürzesten Wege in $G_1$ mithilfe des Algorithmus \textsc{FasterAPSP}.
        Geben Sie nach jedem Schritt die Matrix $L$ an.
        \item Wie muss \textsc{APSP} erweitert werden, sodass neben der Distanzmatrix $D$ auch die Vorgängermatrix $\pi$ korrekt bestimmt wird.
        % \item Erweitern Sie \textsc{APSP}, sodass der Algorithmus zusätzlich erkennt, ob der Graph negative Zyklen enthält.
        % \begin{description}
        %     \item[Tipp:] Wenn ein Pfad $P$ von $v$ zu $v$ existiert mit $w(P) < 0$, liegt $v$ auf einem negativen Zyklus.
        % \end{description}
    \end{enumerate}
\end{aufgabe}

\begin{aufgabe}{2}{Floyd-Warshall-Algorithmus}
    \begin{enumerate}
        \item Bestimmen Sie $D$ und $\pi$ des Graphen $G_1$ mithilfe des Algorithmus von Floyd und Warshall.
        Geben Sie alle Zwischenschritte an.
        \item Angenommen, Sie führen Floyd-Warshall auf einem Graphen mit negativen Zyklen aus.
        Wie können Sie dies anhand der Ausgabe des Algorithmus erkennen?
        \item Angenommen, Sie modifizieren Floyd-Warshall, sodass die Matrix $L$ \emph{in-place} aktualisiert wird, anstatt für jeden Zwischenknoten eine neue Matrix anzulegen ($L^{(1)}, L^{(2)}, \ldots$).
        Begründen Sie, warum der Algorithmus weiterhin korrekt ist.
        \item Es sei ein Graph $G = (V, E)$ gegeben.
        Dann bezeichnet man den Graphen $G^* = (V, E')$ mit $E' = \{(u, v) \mid u \in V, v \in V, \text{$v$ ist von $u$ aus erreichbar}\}$ als transitive Hülle von $G$.
        In $G^*$ kann man also anhand der Kanten sofort ablesen, welche Knoten in $G$ einander erreichen können.
        Geben Sie einen Algorithmus mit Laufzeit $O(n^3)$ in Pseudocode an, der als Eingabe einen Graphen $G$ als Adjazenzmatrix erhält und $G^*$ (als Adjazenzmatrix) ausgibt.
    \end{enumerate}
\end{aufgabe}
\begin{loesung}
    \begin{enumerate}
        \item 
        \item
        Wenn der Graph einen oder mehrere negative Zyklen enthält, ist dies an negativen Werten auf der Hauptdiagonale ($d_{ii}$) der Distanzmatrix $D$ zu erkennen.
        Die Werte der Hauptdiagonale von $D$ geben die Länge des kürzesten Weges von einem Knoten zu sich selbst an.
        Diese Länge sollte im Normalfall 0 sein.
        Ist sie jedoch negativ, ist dies nur durch einen negativen Zyklus möglich.
        Jeder (einfache) Zyklus durchläuft im Schlimmsten fall einmal alle Knoten, bevor er wieder beim Startpunkt ankommt, und umfasst somit maximal $|V|+1$ Knoten.
        Größere Zyklen lassen sich dabei immer in kleinere aufteilen.
        Bei so einem \quotes{maximalen} Zyklus sind alle Knoten bis auf den Start-/Zielknoten des Graphen Zwischenknoten des Pfades.
        Da nach Abschluss von Bellman-Ford alle Knoten als Zwischenknoten berücksichtigt wurden, muss ein negativer Zyklus, falls er existiert, in jedem Fall gefunden worden sein.
        \item
        Im Folgenden ist mit $D$ stets die Matrix des modifizierten \emph{in-place} Algorithmus gemeint, mit $D^{(k)}$ die Matrizen des Ursprungsalgorithmus.

        \emph{Behauptung:} Die Matrix $D$ ist nach der $k$-ten Iteration der äußeren Schleife identisch zu $D^{(k)}$.
        \begin{proof}
            Beweis durch Induktion:
            \begin{description}
                \item[IA:] Vor dem ersten Schleifendurchlauf gilt $D = D^{(0)} = W$.
                \item[IV:] Vor dem $k$-ten Schleifendurchlauf ist $D = D^{(k - 1)}$.
                \item[IS:] Um $d_{ij}^{(k)}$ zu bestimmen, werden die Werte $d_{ij}^{(k - 1)}$, $d_{ik}^{(k - 1)}$ und $d_{kj}^{(k - 1)}$ benötigt.
                Wenn also vor dem Setzen von $d_{ij}$ im $k$-ten Schleifendurchlauf die Werte $d_{ij}$, $d_{ik}$ und $d_{kj}$ unverändert im Vergleich zum vorherigen Durchlauf sind, wird $d_{ij}$ korrekt gesetzt.

                $d_{ij}$ ist trivialerweise unverändert, da es ja gerade erst gesetzt wird.
                $d_{ik}$ und $d_{kj}$ sind auch unverändert, da wir im aktuellen Durchlauf $k$ als Zwischenknoten betrachten. 
                Der Zwischenknoten $k$ hat nur dann Einfluss auf kürzeste Wege, die bei $k$ starten oder enden, wenn $k$ auf einem negativen Zyklus liegt.
                Dies haben wir aber per Definition bei Floyd-Warshall ausgeschlossen.
            \end{description}
            Nach dem Prinzip der Induktion ist $D$ nach dem $k$-ten Schleifendurchlauf für jedes $k$ identisch zu $D^{(k)}$.
        \end{proof}
        Dass der Algorithmus korrekt funktioniert, folgt sofort aus der Behauptung.
        \item 
        Setzt man die Gewichte $w(u, v) = 1$ für alle Kanten $(u, v) \in E$ fest und führt man den Floyd-Warshall-Algorithmus aus, kann man die Erreichbarkeit zwischen Knoten in der Matrix $D$ ablesen: $D_{ij} < \infty \Leftrightarrow \text{$j$ ist von $i$ aus erreichbar}$.
        Wenn allerdings nur die Erreichbarkeit relevant ist und nicht der Abstand, kann man auch eine vereinfachte Variante von Floyd-Warshall nutzen, die auf das Relaxieren komplett verzichtet wird und in den Matrizen $D^{(k)}$ nur die Erreichbarkeit und nicht der Abstand gespeichert wird:
        \begin{algorithmic}[1]
            \Procedure{TransitiveClosure}{$V, E$}
                \State $D \gets E$
                \For{$i \gets 1 \text{ \textbf{to} } |V|$}
                    \State $d_{ii} \gets 1$ \Comment{Jeder Knoten kann sich selbst erreichen}
                \EndFor
                \For{$k \in V$}
                    \For{$i \gets 1 \text{ \textbf{to} } |V|$}
                        \For{$j \gets 1 \text{ \textbf{to} } |V|$}
                            \State $d_{ij} \gets d_{ij} \vee (d_{ik} \wedge d_{kj})$
                            \Comment{Update: Ist $j$ von $i$ über $k$ erreichbar?}
                        \EndFor
                    \EndFor
                \EndFor
                \State \Return $D$
            \EndProcedure
        \end{algorithmic}
    \end{enumerate}
\end{loesung}

\begin{aufgabe}{3}{Dynamische Programmierung}
    Gegeben sei ein Array $(a_1, a_2, \ldots, a_n)$ mit $a_i \in \mathbb{Z}$ für $1 \leq i \leq n$.
    Eine aufsteigende Subsequenz des Arrays ist definiert als eine Folge $s_1, s_2, \ldots, s_{k - 1}, s_k$ mit $1 \leq s_1 < s_2 < \ldots < s_k \leq n$ und $a_{s_1} < a_{s_2} < \ldots < a_{s_k}$.
    Gesucht ist die längste, aufsteigende Subsequenz.
    \begin{description}
        \item[Beispiel:] Eingabe: $(7, 12, 4, 8, 6, 8, 9, 8, 11)$ $\rightarrow$ Ausgabe: $(3, 5, 6, 7, 9)$ mit $k = 5$. Dies entspricht den Elementen~$(4, 6, 8, 9, 11)$ des Arrays.
    \end{description}
    \begin{enumerate}[label=\alph*)]
        \item\label{optimal_substructure} Beschreiben Sie kurz, inwiefern die längste, aufsteigende Subsequenz die Eigenschaften einer optimalen Substruktur besitzt.
        \item\label{dynamic} Implementieren Sie einen Algorithmus in Pseudocode oder einer Programmiersprache Ihrer Wahl mit Laufzeit $O(n^2)$ nach dem Prinzip der dynamischen Programmierung, welcher ein Array $a$ als Eingabe erhält und $k$ ausgibt, die Länge der längsten, aufsteigenden Subsequenz $s_1, \ldots, s_k$.
        \begin{description}
            \item[Tipp:] Berechnen Sie für jedes $i$ ($1 \leq i \leq n$) die Länge der längsten, aufsteigenden Subsequenz die bei $a_i$ endet ($s_k = i$) und geben Sie abschießend das Maximum dieser Werte zurück.
        \end{description}
        \item Erweitern Sie Ihren Algorithmus, sodass dieser neben der Länge $k$ der Sequenz $a_{s_1}, a_{s_2}, \ldots, a_{s_k}$ auch die Sequenz selbst ausgibt.
        Die Laufzeit soll weiterhin $O(n^2)$ betragen.
        \item
        Formulieren Sie obiges Problem als Graphproblem.
        Interpretieren Sie hierfür die Werte des Arrays als Knoten eines Graphen.
        Ziehen Sie sie von $a_i$ nach $a_j$ immer dann eine Kante, wenn $i < j$ und $a_i < a_j$.
        Nennen Sie einen Algorithmus aus der Vorlesung, mit dem Sie entsprechende Graphproblem lösen können.
    \end{enumerate}
\end{aufgabe}
\begin{loesung}
    \begin{enumerate}
        \item Es sei eine längste, aufsteigende Subsequenz $s_1, s_2, \ldots, s_i, \ldots, s_j, \ldots, s_{k - 1}, s_k$ gegeben.
        Nun wird die Teilsequenz $s_i, s_{i + 1}, \ldots s_{j - 1}, s_j$ betrachtet.
        Diese Teilsequenz ist eine längste, aufsteigende Subsequenz des Teilarrays $a_{s_i}, a_{s_i + 1}, \ldots, a_{s_j - 1}, a_{s_j}$ unter den Nebenbedingungen, dass $a_{s_{i - 1}} < a_{s_i}$ und $a_{s_j} < a_{s_{j + 1}}$.
        Gäbe es nämlich eine längere, aufsteigende Subsequenz in diesem Teilarray unter obigen Nebenbedingungen, könnte man diese (analog zum Beweis der optimalen Substruktur kürzester Wege) in die ursprüngliche, längste, aufsteigende Subsequenz $s_1, \ldots, s_k$ einsetzen und diese damit verlängern.

        Man kann das betrachtete Teilarray sogar auf $a_{s_{i - 1} + 1}, a_{s_{i - 1} + 2}, \ldots a_{s_i}, \ldots, a_{s_j}, \ldots, a_{s_{j + 1} - 2}, a_{s_{j + 1} - 1}$ ausweiten.
        $s_i, \ldots, s_j$ ist im erweitereten Teilarray weiterhin eine längste, aufsteigende Subsequenz (unter besagten Nebenbedigungen).

        \item 
        Das Array $a$ wird von links nach rechts durchlaufen. Für jedes Element $a_i$ wird die Länge $l_i$ der längsten, aufsteigenden Subsequenz bestimmt, die bei $a_i$ endet (siehe Tipp).
        Diese Längen werden in einem temporären Array gespeichert.
        Um $l_i$ zu bestimmen, können so die Längen bei allen vorherigen Elemente ($l_1, l_2, \ldots, l_{i-1}$) verwendet werden.
        
        Für die längste, aufsteigende Subsequenz, die bei $a_i$ endet, gibt es zwei Möglichkeiten:
        Entweder enthält sie nur das Element $a_i$ und besitzt somit Länge 1.
        Oder sie ist länger.
        In diesem Fall enthält sie zusätzlich weitere Elemente aus der Menge $\{a_1, a_2, \ldots, a_{i - 1}\}$.
        Seien dies die Elemente $(a_{s_1}, a_{s_2}, \ldots, a_{s_l})$.
        Aufgrund der Eigentschaften aufsteigender Subsequenzen gilt dann $1 \leq s_1 < s_2 < \ldots < s_l < i$ sowie außerdem $a_{s_1} < a_{s_2} < \ldots < a_{s_l} < a_i$.
        Da längste, aufsteigende Subsequenzen eine optimale Substruktur bilden (siehe Teilaufgabe \ref*{optimal_substructure}), muss $s_1, s_2, \ldots, s_l$ die längste, aufsteigende Subsequenz im Bereich $[1, i - 1]$ sein unter der zusätzlichen Einschränkung, dass $a_{s_l} < a_i$.

        Die Länge $l$ dieser Subsequenz entspricht $\max\{l_j \mid j \in \{1, 2, \ldots, i - 1\}, a_j < a_i\}$.
        Es gilt dann also $l_i = l + 1$.
        Für jedes $i$ kann man also $l_i$ leicht bestimmen, indem man über alle $l_1, l_2, \ldots, l_{i - 1}$ iteriert und das Maximium aller $l_j$ bestimmt, für die $a_j < a_i$ gilt.
        Schließlich muss man nur noch $k = \max\{l_i | i \in \{1, 2, \ldots, n\}\}$ bestimmen.
        \begin{lstlisting}[language=c++]
int longestIncreasingSubsequence(int a[], int n) {
    int *seqLen = new int[n];
    int k = 1;
    for (int i = 0; i < n; i++) {
        seqLen[i] = 1;
    }
    for (int i = 1; i < n; i++) {
        for (int j = 0; j < i; j++) {
            if (a[j] < a[i]) {
                seqLen[i] = max(seqLen[i], seqLen[j] + 1);
                k = max(k, seqLen[i]);
            }
        }
    }
    return k;
} 
        \end{lstlisting}
        Die Laufzeit wird dominiert durch die beiden verschachtelten \texttt{for}-Schleifen.
        Deren Laufzeit ergibt sich durch die Gaußsumme: $\Theta(n^2)$.
        \item Jedes Mal, wenn ein $l_i$ aktualisiert wird, muss zusätzlich gespeichert werden welches $a_j$ ($1 \leq j < i$) vor $a_i$ in der längsten, bei $a_i$ endenden, aufsteigenden Subsequenz steht.
        Dies geschiet im Beispeilcode unten mithilfe des Hilfsarrays \texttt{prev}.
        Jedes Mal, wenn man eine neue, längste, aufsteigende Subsequenz findet ($l_i > k$), aktualisiert man nicht nur $k$, sondern merkt sich auch das $i$, bei dem das $k$ erreicht wurde.
        Auf diese Weise kennt man, nachdem alle $l_i$ bestimmt wurden, die Endposition der längsten, aufsteigenden Subsequenz.
        Außerdem kann man mittels \texttt{prev} die gesamte Sequenz von hinten nach vorne rekonstruieren.
        \begin{lstlisting}[language=c++]
int longestIncreasingSubsequenceExt(int a[], int n, int **solP) {
    int *seqLen = new int[n];
    int *prev = new int[n];
    int k = 1;
    int kIndex = 0;
    for (int i = 0; i < n; i++) {
        seqLen[i] = 1;
        prev[i] = -1;
    }
    for (int i = 1; i < n; i++) {
        for (int j = 0; j < i; j++) {
            if (a[j] < a[i] && seqLen[j] + 1 > seqLen[i]) {
                seqLen[i] = seqLen[j] + 1;
                prev[i] = j;
                if (seqLen[i] > k) {
                    k = seqLen[i];
                    kIndex = i;
                }
            }
        }
    }
    int *sol = new int[k];
    int j = kIndex;
    for (int i = k - 1; i >= 0; i--) {
        sol[i] = a[j];
        j = prev[j];
    }
    *solP = sol;
    return k;
}
        \end{lstlisting}
        Im Wesentlichen kommt im Vergleich zum Ursprungsalgorithmus eine weitere \texttt{for}-Schleife hinzu, die $k \leq n = O(n)$ Iterationen durchläuft.
        Die Laufzeit $O(n^2)$ ändert sich also nicht.

        \item Wird ein Graph gemäß der Aufgabenstellung erstellt, entspricht jeder Pfad zwischen zwei Knoten im Graphen einer aufsteigenden Subsequenz.
        Die längste, aufsteigende Subsequenz entspricht daher dem längsten Pfad im Graphen.
        Diesen längsten Pfad kann man beispielsweise mittels Floyd-Warshall finden.
        Dafür legt man für alle $(u, v) \in E$ das Kantengewicht $w(u, v) = -1$ fest.
        Anschließend sucht man alle kürzesten Wege im Graphen mittels Floyd-Warshall. Der kürzeste Weg gemäß obiger Gewichte entspricht dem längsten Weg nach Kantenanzahl und somit der längsten, aufsteigenden Subsequenz.
        Negative Zyklen kann es nicht geben, da Kanten nur von kleinen zu großen Arrayindezes existieren (siehe Bedingung $i < j$) und der Graph somit azyklisch ist.
        Die Laufzeit von Floyd-Warshall wäre mit $O(n^3)$ schlechter als die des in den letzten beiden Teilaufgaben entwickelten Algorithmus ($O(n^2)$).
    \end{enumerate}
\end{loesung}

\begin{aufgabe}{4}{Lernen regulärer Sprachen: $\mathrm{L}^*$, $\mathrm{NL}^*$}
    Gegeben sei die Sprache $L$ über dem Alphabet $\Sigma = \{a, b\}$, die durch den regulären Ausdruck $(a|b)^*ab(a|b)$ definiert ist. $L$ enthält also genau die Wörter, die auf $aba$ oder $abb$ enden.
    \begin{enumerate}
        \item Bestimmen die einen minimalen DEA $M$ mit $\mathcal{L}(M) = L$ mithilfe des Algorithmus $\mathrm{L}^*$. Geben Sie alle Zwischenschritte an (Herstellen von Geschlossenheit und Konsistenz, Äquivalenzfragen).
        \item Bestimmen den kanonischen RFSA $M$ mit $\mathcal{L}(M) = L$ mithilfe des Algorithmus $\mathrm{NL}^*$. Geben Sie alle Zwischenschritte an (Herstellen von Geschlossenheit und Konsistenz, Äquivalenzfragen).
        \item Angenommen, Sie haben einen DEA $M = (Q, q_0, \delta, F)$ und ein Wort $w \in \Sigma^*$ gegeben.
        Beschreiben Sie mittels Pseudocode, wie Sie überprüfen können, ob $w \in \mathcal{L}(M)$. Geben Sie Laufzeit und Speicherbedarf Ihres Algorithmus an, abhängig von $n = |Q|$ und $m = |w|$.
        \begin{description}
            \item[Hinweis:] Das Berechnen von $\delta$ und das Bestimmen, ob $q \in F$, benötigt nur konstante Laufzeit.
        \end{description}
        \item Angenommen, Sie haben stattdessen einen NEA $M = (Q, Q_0, \delta, F)$ gegeben.
        Geben Sie einen Algorithmus in Pseudocode an, der für ein Wort $w \in \Sigma^*$ prüft, ob $w \in \mathcal{L}(M)$.
        Welche Laufzeit und Speicherbedarf besitzt Ihr Algorithmus?
    \end{enumerate}
\end{aufgabe}

\begin{loesung}
    \begin{enumerate}
        \item 
        \item 
        \item 
        \begin{algorithmic}[1]
            \Procedure{IsInLanguage}{$(Q, q_0, \delta, F), w$}
                \State $q \gets q_0$
                \For{$i \gets 1 \text{ \textbf{to} } |w|$}
                    \State $q \gets \delta(q, w_i)$
                \EndFor
                \State \Return $q \in F$
            \EndProcedure
        \end{algorithmic}
        \item 
        \begin{algorithmic}[1]
            \Procedure{IsInLanguage}{$(Q, q_0, \delta, F), w$}
                \State $\hat{q} \gets q_0$
                \For{$i \gets 1 \text{ \textbf{to} } |w|$}
                    \State $\hat{q}' \gets \varnothing$
                    \For{$q \in \hat{q}$}
                        \State $\hat{q}' \gets \hat{q} \cup \delta(q, w_i)$
                    \EndFor
                    \State $\hat{q} \gets \hat{q}'$
                \EndFor
                \For{$q \in \hat{q}$}
                    \If{$q \in F$}
                        \State \Return \textbf{true}
                    \EndIf
                \EndFor
                \State \Return \textbf{false}
            \EndProcedure
        \end{algorithmic}
    \end{enumerate}
\end{loesung}

\end{document}