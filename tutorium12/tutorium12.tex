\documentclass[11pt,a4paper]{article}

\usepackage{gastex}
\usepackage{etoolbox}
% \newcommand{\showLoesung}{2} %<---als Schalter
% \newcommand{\showInhalt}{1} %<---als Schalter

\input{../skel/uebmacsPNG}

\usepackage{enumitem}
\usepackage{algpseudocode}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{placeins}
\usepackage{multicol}
\usepackage{slashbox}
\usepackage{fancyvrb}
\usepackage{ulem}
\usepackage{amssymb}

\begin{document}
\thispagestyle{empty}
\DeclareRobustCommand{\ttfamily}{\fontencoding{T1}\fontfamily{lmtt}\selectfont}

\newcommand{\quotes}[1]{\glqq{}#1\grqq{}}

\Uebung{12}{13}{Simon Thelen}{20. Januar 2021}  % FIXME: Blattnummer, Datum, Zeit

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\ifcsdef{showLoesung}{
\textbf{Bitte beachten Sie:} Die Lösungen können trotz sorgfältiger Prüfung Fehler enthalten.
Bei Fragen oder Unklarheiten kontaktieren Sie bitte den Tutor oder Dozenten in Tutorien, Übungen oder nach Vorlesungen.
}{}

\begin{aufgabe}{3}{Dynamische Programmierung}
    Gegeben sei ein Array $(a_1, a_2, \ldots, a_n)$ mit $a_i \in \mathbb{Z}$ für $1 \leq i \leq n$.
    Eine aufsteigende Subsequenz des Arrays ist definiert als eine Folge $s_1, s_2, \ldots, s_{k - 1}, s_k$ mit $1 \leq s_1 < s_2 < \ldots < s_k \leq n$ und $a_{s_1} < a_{s_2} < \ldots < a_{s_k}$.
    Gesucht ist die längste, aufsteigende Subsequenz.
    \begin{description}
        \item[Beispiel:] Eingabe: $(7, 12, 4, 8, 6, 8, 9, 8, 11)$ $\rightarrow$ Ausgabe: $(3, 5, 6, 7, 9)$ mit $k = 5$. Dies entspricht den Elementen~$(4, 6, 8, 9, 11)$ des Arrays.
    \end{description}
    \begin{enumerate}[label=\alph*)]
        \item\label{optimal_substructure} Beschreiben Sie kurz, inwiefern die längste, aufsteigende Subsequenz die Eigenschaften einer optimalen Substruktur besitzt.
        \item\label{dynamic} Implementieren Sie einen Algorithmus in Pseudocode oder einer Programmiersprache Ihrer Wahl nach dem Prinzip der dynamischen Programmierung mit Laufzeit $O(n^2)$, welcher $k$, die Länge der längsten, aufsteigenden Subsequenz $s_1, \ldots, s_k$ ausgibt.
        \begin{description}
            \item[Tipp:] Berechnen Sie für jedes $i$ ($1 \leq i \leq n$) die Länge der längsten, aufsteigenden Subsequenz die bei $a_i$ endet ($s_k = i$) und geben Sie abschießend das Maximum dieser Werte zurück.
        \end{description}
        \item Erweitern Sie Ihren Algorithmus aus Teilaufgabe~\ref*{dynamic}, sodass dieser neben der Länge $k$ der Sequenz $a_{s_1}, a_{s_2}, \ldots, a_{s_k}$ auch die Sequenz selbst ausgibt, ohne die Laufzeit im $O$-Kalkül zu verschlechtern.
        \item Wie können Sie das obige Problem als Graphproblem formulieren, wenn Sie jeden Wert $a_i$ des Arrays als Knoten interpretieren und sie zwischen $a_i$ und $a_j$ immer dann eine Kante ziehen, wenn $a_i < a_j$.
        Nennen Sie einen Algorithmus aus der Vorlesung, mit dem Sie das entsprechende Graphproblem lösen können.
    \end{enumerate}
\end{aufgabe}
\begin{loesung}
    \begin{enumerate}
        \item Es sei eine längste, aufsteigende Subsequenz $s_1, s_2, \ldots, s_i, \ldots, s_j, \ldots, s_{k - 1}, s_k$ gegeben.
        Nun wird die Teilsequenz $s_i, s_{i + 1}, \ldots s_{j - 1}, s_j$ betrachtet.
        Diese Teilsequenz ist eine längste, aufsteigende Subsequenz des Teilarrays $a_{s_i}, a_{s_i + 1}, \ldots, a_{s_j - 1}, a_{s_j}$ unter den Nebenbedingungen, dass $a_{s_{i - 1}} < a_{s_i}$ und $a_{s_j} < a_{s_{j + 1}}$.
        Gäbe es nämlich eine längere, aufsteigende Subsequenz in diesem Teilarray unter obigen Nebenbedingungen, könnte man diese (analog zum Beweis der optimalen Substruktur kürzester Wege) in die ursprüngliche, längste, aufsteigende Subsequenz $s_1, \ldots, s_k$ einsetzen und diese damit verlängern.

        Man kann das betrachtete Teilarray sogar auf $a_{s_{i - 1} + 1}, a_{s_{i - 1} + 2}, \ldots a_{s_i}, \ldots, a_{s_j}, \ldots, a_{s_{j + 1} - 2}, a_{s_{j + 1} - 1}$ ausweiten.
        $s_i, \ldots, s_j$ ist im erweitereten Teilarray weiterhin eine längste, aufsteigende Subsequenz (unter besagten Nebenbedigungen).

        \item 
        Das Array $a$ wird von links nach rechts durchlaufen. Für jedes Element $a_i$ wird die Länge $l_i$ der längsten, aufsteigenden Subsequenz bestimmt, die bei $a_i$ endet (siehe Tipp).
        Diese Längen werden in einem temporären Array gespeichert.
        Um $l_i$ zu bestimmen, können so die Längen bei allen vorherigen Elemente ($l_1, l_2, \ldots, l_{i-1}$) verwendet werden.
        
        Für die längste, aufsteigende Subsequenz, die bei $a_i$ endet, gibt es zwei Möglichkeiten:
        Entweder enthält sie nur das Element $a_i$ und besitzt somit Länge 1.
        Oder sie ist länger.
        In diesem Fall enthält sie zusätzlich weitere Elemente aus der Menge $\{a_1, a_2, \ldots, a_{i - 1}\}$.
        Seien dies die Elemente $(a_{s_1}, a_{s_2}, \ldots, a_{s_l})$.
        Aufgrund der Eigentschaften aufsteigender Subsequenzen gilt dann $1 \leq s_1 < s_2 < \ldots < s_l < i$ sowie außerdem $a_{s_1} < a_{s_2} < \ldots < a_{s_l} < a_i$.
        Da längste, aufsteigende Subsequenzen eine optimale Substruktur bilden (siehe Teilaufgabe \ref*{optimal_substructure}), muss $s_1, s_2, \ldots, s_l$ die längste, aufsteigende Subsequenz im Bereich $[1, i - 1]$ sein unter der zusätzlichen Einschränkung, dass $a_{s_l} < a_i$.

        Die Länge $l$ dieser Subsequenz entspricht $\max\{l_j \mid j \in \{1, 2, \ldots, i - 1\}, a_j < a_i\}$.
        Es gilt dann also $l_i = l + 1$.
        Für jedes $i$ kann man also $l_i$ leicht bestimmen, indem man über alle $l_1, l_2, \ldots, l_{i - 1}$ iteriert und das Maximium aller $l_j$ bestimmt, für die $a_j < a_i$ gilt.
        Schließlich muss man nur noch $k = \max\{l_i | i \in \{1, 2, \ldots, n\}\}$ bestimmen.
        \begin{lstlisting}[language=c++]
int longestIncreasingSubsequence(int a[], int n) {
    int *seqLen = new int[n];
    int k = 1;
    for (int i = 0; i < n; i++) {
        seqLen[i] = 1;
    }
    for (int i = 1; i < n; i++) {
        for (int j = 0; j < i; j++) {
            if (a[j] < a[i]) {
                seqLen[i] = max(seqLen[i], seqLen[j] + 1);
                k = max(k, seqLen[i]);
            }
        }
    }
    return k;
} 
        \end{lstlisting}
        Die Laufzeit wird dominiert durch die beiden verschachtelten \texttt{for}-Schleifen.
        Deren Laufzeit ergibt sich durch die Gaußsumme: $\Theta(n^2)$.
        \item Jedes Mal, wenn ein $l_i$ aktualisiert wird, muss zusätzlich gespeichert werden welches $a_j$ ($1 \leq j < i$) vor $a_i$ in der längsten, bei $a_i$ endenden, aufsteigenden Subsequenz steht.
        Dies geschiet im Beispeilcode unten mithilfe des Hilfsarrays \texttt{prev}.
        Jedes Mal, wenn man eine neue, längste, aufsteigende Subsequenz findet ($l_i > k$), aktualisiert man nicht nur $k$, sondern merkt sich auch das $i$, bei dem das $k$ erreicht wurde.
        Auf diese Weise kennt man, nachdem alle $l_i$ bestimmt wurden, die Endposition der längsten, aufsteigenden Subsequenz.
        Außerdem kann man mittels \texttt{prev} die gesamte Sequenz von hinten nach vorne rekonstruieren.
        \begin{lstlisting}[language=c++]
int longestIncreasingSubsequenceExt(int a[], int n, int **solP) {
    int *seqLen = new int[n];
    int *prev = new int[n];
    int k = 1;
    int kIndex = 0;
    for (int i = 0; i < n; i++) {
        seqLen[i] = 1;
        prev[i] = -1;
    }
    for (int i = 1; i < n; i++) {
        for (int j = 0; j < i; j++) {
            if (a[j] < a[i] && seqLen[j] + 1 > seqLen[i]) {
                seqLen[i] = seqLen[j] + 1;
                prev[i] = j;
                if (seqLen[i] > k) {
                    k = seqLen[i];
                    kIndex = i;
                }
            }
        }
    }
    int *sol = new int[k];
    int j = kIndex;
    for (int i = k - 1; i >= 0; i--) {
        sol[i] = a[j];
        j = prev[j];
    }
    *solP = sol;
    return k;
}
        \end{lstlisting}
        Im Wesentlichen kommt im Vergleich zum Ursprungsalgorithmus eine weitere \texttt{for}-Schleife hinzu, die $k \leq n = O(n)$ Iterationen durchläuft.
        Die Laufzeit $O(n^2)$ ändert sich also nicht.

        \item Wird ein Graph gemäß der Aufgabenstellung erstellt, entspricht die längste, aufsteigende Subsequenz dem längsten Pfad im Graphen.
        Diesen längsten Pfad kann man beispielsweise mittels Floyd-Warshall finden.
        Dafür legt man für alle $(u, v) \in E$ das Kantengewicht $w(u, v) = -1$ fest.
        Anschließend sucht man alle kürzesten Wege im Graphen mittels Floyd-Warshall. Der kürzeste Weg gemäß obiger Gewichte entspricht dem längsten Weg nach Kantenanzahl und somit der längsten, aufsteigenden Subsequenz.
        Die Laufzeit wäre aber mit $O(n^3)$ schlechter als die des in den letzten beiden Teilaufgaben entwickelten Algorithmus ($O(n^2)$).
    \end{enumerate}
\end{loesung}

\end{document}